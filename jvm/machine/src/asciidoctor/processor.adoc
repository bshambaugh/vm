:imagesdir: ./images/processor

== Processor Structures

The programs of the mm-ADT virtual machine are _types_. From a set of canonical types (_ctypes_), derived types (_dtypes_) of arbitrary complexity can be constructed using instructions from the VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture]. Every mm-ADT type has a corresponding https://en.wikipedia.org/wiki/Diagram_(category_theory)[diagrammatic] representation that is https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to a directed labeled *type graph* composed of _type_-vertices and _instruction_-edges.

A program's type graph is the https://en.wikipedia.org/wiki/Intermediate_representation[intermediate representation] used by the mm-ADT VM to not only link types (encode), but also to compile them (transform/optimize). At execution time, values propagate through the type graph and generate a parallel, homomorphic image of the types as values in the *value graph*, where the resultant structure of an mm-ADT computation is the *obj graph*, where

\[
\texttt{obj} = (\texttt{type} \times \texttt{q}) + (\texttt{value} \times \texttt{q})
\]

image::process-stack.png[float="right",width=200]

Type composition, compilation, and evaluation are carried out by mm-ADT compliant *processors*. Processors ground the mm-ADT VM to the underlying physical computer (whether on a single machine, via multiple threads, or across compute cluster), where, at the bottom of this _process stack_, the natural world's physics provides the baseline dynamics (the fundamental ground of the computation).

This section details the specifics of the relationships between types, values, and processors.

=== Processes

Processors are used in the following three situations:

. *Composition*: (https://en.wikipedia.org/wiki/Type_inference[type inference]).
. *Compilation*: (https://en.wikipedia.org/wiki/Program_optimization[type optimization]). (https://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29[fix point]).
. *Evaluation*: (https://en.wikipedia.org/wiki/Execution_(computing)[type enumeration]).

=== Obj Graph

The mm-ADT virtual machine computes via two https://en.wikipedia.org/wiki/Semigroup_action[actions] on the `obj` graph. A thread of execution in the VM maintains two primary references: 1.) a reference to an `obj` and 2.) a reference to an `inst`. Via the juxtaposition of `obj` and `inst` another `obj` is realized. This process occurs within a larger referential structure called the `obj` graph. The aim of this section is to codify this process and organize the complexities of the `obj` graph.

When a VM process refers to the `obj` \$a\$ and the instruction `inst` \$i\$, then the VM will perform one of the following operations.

. If the vertex \$a\$ has no outgoing \$i\$-labeled edge, then the VM _applies_ \$a\$ to \$i\$ to yield the edge \$a \to_i b\$ and arrive at \$b\$ (*compute*).
. If the vertex \$a\$ has an outgoing \$i\$-labeled edge, then the VM _traverses_ the edge \$a \to_i b\$ to arrive at \$b\$ (*memoize*).

The first situation is computing via function https://en.wikipedia.org/wiki/Evaluation_strategy[evaluation] (save space). The second situation leverages https://en.wikipedia.org/wiki/Memoization[memoization] to avoid recomputing (save time). This two situations help frame three high-level perspectives on the `obj` graph.

. *Mathematically*: The `obj` graph has an infinite number of `obj` vertices connected to each other by edges labeled from the infinite https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] `inst`. From this perspective, computing is traversal (i.e. https://en.wikipedia.org/wiki/Lookup_table[look-up]) as the `obj` graph is fully materialized.
. *Theoretically*: The `obj` graph is manifested as computations proceed where, if \$a \in \tt{obj}\$ and \$i \in \tt{i\nst}\$, then any binary operation \$ai\$ that has already been evaluated already exists in the `obj` graph and as such, can be traversed.
. *Physically*: The `obj` graph is a dynamic entity that expands and contracts given the resource constraints of the underlying physical machines supporting its manifestation across all levels of the https://en.wikipedia.org/wiki/Memory_hierarchy[memory hierarchy], where https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)[garbage collection] prunes the graph and computation grows the graph.

==== Algebraic Actions

===== Type Specification

An mm-ADT *program* in an mm-ADT *type*. In the type graph (a subgraph of the `obj` graph) a type is denoted by a vertex (an _ungrounded_ vertex). That vertex is the type's *range*. The type's *definition* is encoded in the directed, https://en.wikipedia.org/wiki/Deterministic_automaton[deterministic] path that ends at a vertex with no outgoing edges. The resultant vertex is a _root_ vertex and is the type's *domain*. If the type definition's path length is 0, then the domain and the range are equal, and the type is a ctype (a canonical type). If the path length is greater than 0, then the directed binary edges of the path are labeled with instructions from `inst`. This construction is abstractly represented in the diagram below.


image::../processor/type-path.png[align=center,width=800]

The type graph forms the central structure upon by which various VM processes are enacted. These processes include type/program specification, compilation, optimization, and ultimately, via a https://en.wikipedia.org/wiki/Homomorphism[homomorphism] from the type graph to the value graph, evaluation. Given finite computing resources, the type graph does not exist eternally in a static form ready-made. No, instead, subgraphs of it must be generated. This is accomplished via an action of `inst` monoid on the set `inst^*^` (the https://en.wikipedia.org/wiki/Kleene_star[Kleene star] closure of `inst`). For instance, in `mmlang` the user juxtaposes a ctype (domain) and an `inst` to construct a dtype. That dtype is juxtaposed with another `inst` to yield another dtype so forth until a desired type is reached.

\[
\texttt{range} = ((((((\texttt{domain} \cdot \texttt{inst}_0) \cdot \texttt{inst}_1) \cdot \texttt{inst}_2) \ldots) \cdot \texttt{inst}_{n-2}) \cdot \texttt{inst}_{n-1}).
\]

In general, the action of an `inst` on a type is the function
\[
\texttt{inst}: T \to T,
\]
where if \$a \in \tt{i\nst}\$, then
\[
a(x) = xa.
\]

Said plainly, instructions in `inst` act on types by concatenating themselves to the type definition. Algebraically, a type is an element of the https://en.wikipedia.org/wiki/Free_algebra[free] inst monoid rooted a ctype.

==== Type Compilation

==== Type Optimization

==== Type Evaluation

===== Instruction Evaluation

Every mm-ADT instruction denotes a https://en.wikipedia.org/wiki/Unary_function[unary function], but mm-ADT instructions themselves may contain zero, one, or multiple sub-expressions as arguments.
At the mm-ADT type-level, mm-ADT instructions are \$n\$-ary computable relations, where through currying and stream semantics, ultimately, unary functions are realized.

===== n-Ary Instructions

Instructions that have no arguments and which map one input to one output are *nullary instructions*.
For example, `[neg]` (negative/negate) is a nullary instruction in the type `int[neg]` denoting the unary function \[
\begin{array}.
\texttt{neg} &:& \mathbb{N} \rightarrow \mathbb{N} \\ \texttt{neg}(x) &\mapsto& -x.
\end{array}
\]

The *unary instruction* `[plus,2]` in `int[plus,2]` is evaluated by the processor as the unary function \[
\begin{array}.
\texttt{plus_2} &:& \mathbb{N} \rightarrow \mathbb{N} \\ \texttt{plus_2}(x) &\mapsto& x + 2. \end{array}
\]

Instructions can have arguments that are dependent on the incoming `obj` (i.e. the unary function argument).
For instance, the unary instruction `[plus,[mult,3]]` in `int[plus,int[mult,3]]` denotes the unary function \[
\begin{array}.
\texttt{plus_mult_3} &:& \mathbb{N} \rightarrow \mathbb{N} \\ \texttt{plus_mult_3}(x) &\mapsto& x + (x * 3).
\end{array}
\]

Finally, as example instruction when the domain and range differ, `[gt,[plus,[id]]]` in \[
\tt{bool<=int[gt,int[plus,int[id]]]} \]
denotes the unary function \[
\begin{array}.
\texttt{gt_plus_id} &:& \mathbb{N} \rightarrow \{\texttt{true} \cup \texttt{false}\} \\ \texttt{gt_plus_id}(x) &\mapsto& x > (x + x).
\end{array}
\]

===== n-Ary Relations

==== Instruction Classes

===== Map

===== Filter

===== Trace

===== Branch

=== Processor Implementations