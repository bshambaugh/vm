= mm-ADT: The Virtual Machine
Marko A. Rodriguez <marko@rredux.com>
:project-version:
:icons: font
:toc: left
:toclevels: 3
:doctype: book
:docinfo: shared-head
:stem: latexmath
:favicon: ./images/favicon.ico
:source-highlighter: coderay
:source-language: Delphi
:stylesdir: ./css
// :stylesheet: mmadt.css

//\[
//\int_0^1 x^n dx = \frac{1}{n+1}
//\]

image::images/mm-adt-logo.png[mm-ADT Logo,float="left",width=150]

http://mm-adt.org[mm-ADT] is a dual licensed https://www.gnu.org/licenses/agpl-3.0.txt[AGPL3]/commercial open source project that offers software engineers, computer scientists, mathematicians, and others in the software industry a royalty-based OSS model. The Turing Complete mm-ADT virtual machine (VM) integrates disparate data technologies via algebraic composition, yielding _synthetic data systems_  tailored to the computational requirements of a problem. As an economic model, each integration point offers the respective development team access to the revenue streams generated by any for-profit organization leveraging mm-ADT.

== Virtual Machine Components

[ditaa,"vm-components",align="center",float="right",shadows=false]
....
  /---------------------\
  |            mmADT VM |
  |                     |
  | bool,int,str,rec,.. |
  | strm,model,...      |
  | map,filter,branch,..|
  |                     |
  \-----*----*-----*----/
        |    |     |
    /---/    |     \-----\
    |        |           |
+---*----+ +-*-----+ +---*-----+
|{d}     | |  {s}  | | {io}    |
|        | |       | |         |
|language| |storage| |processor|
|        | |       | |         |
+--------+ +-------+ +---------+
....

The mm-ADT VM is the integration point for the following data processing technologies:

* *Programming Languages*: Language designers can create custom languages or develop parsers for existing languages that compile to mm-ADT VM bytecode (binary machine code) or unicode (text assembly code).
* *Storage Systems*: Storage engineers can embed their systems using _model-ADT_ functors expressed in mm-ADT's dependent type system that enable the lossless encoding of key/value store, document store, wide-column store, graph store, relational store, and other novel or hybrid structures such as hypergraph, docu-graph, and quantum data structures.
* *Processing Engines*: Processor developers enable their push- or pull-based execution engines to be programmed by any mm-ADT language for evaluation via mm-ADT's abstract execution model of atomic monadic traversers diffusing themselves over storage data structure via single-machine, multi-threaded, agent-based, distributed near-time, and/or cluster-oriented, batch-analytic processors.


The mm-ADT VM enables the intermingling of any language, any storage system, and any processor that can faithfully implement the core language semantics (types and values), storage semantics (streams of atomic and composite data structures), and/or processor semantics (monadic traversers up to the limits of the expressiveness of the components themselves.

=== The mm-ADT Console

The mm-ADT VM provides a https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop:[REPL] console for users to evaluate mm-ADT programs written in any mm-ADT language. The reference language distributed with the VM is called `mmlang`. `mmlang` is a low-level, functional language that is in near 1-to-1 correspondence with the underlying VM architecture -- offering it's users https://en.wikipedia.org/wiki/Turing_completeness[Turing-Complete] expressively when writing programs and an interactive teaching tool for studying the internal structures and processes of the mm-ADT VM.

[source,text]
----
~/mm-adt bin/mmadt.sh
                                _____ _______
                           /\  |  __ |__   __|
 _ __ ___  _ __ ___ _____ /  \ | |  | | | |
| '_ ` _ \| '_ ` _ |_____/ /\ \| |  | | | |
| | | | | | | | | | |   / ____ \ |__| | | |
|_| |_| |_|_| |_| |_|  /_/    \_\____/  |_|
                                 mm-adt.org
mmlang>
----

A simple console session is presented below, where the parser expects programs written in the language specified left
of the `>` prompt. All the examples contained herein are presented using `mmlang`.

[source]
----
mmlang> 1
==>1
mmlang> +2
==>[plus,2]
mmlang> 1+2
==>3
mmlang> 1[plus,2]
==>3
----

== Language Structures

[ditaa,"types-and-values",align="left",float="left"]
....
 /->obj<-\
 |       |
 |       |
type   value
....

The mm-ADT VM operates on _objects_ denoted `obj`. Every mm-ADT `obj` is either a *type* or a *value*.

\[ \texttt{obj} = \texttt{type} + \texttt{value} \]

It is via types and their composition that program
are specified, sets constructed, functions defined, and mappings between different abstract data types realized.
Values, on the other hand, are simple datum optimized for migration around a compute cluster.

=== Types

[ditaa,"types-instructions-quantifiers",float="right"]
....
 /-type-\
 |      |
 v      v

inst    q
....

The infinite set of all mm-ADT types can be constructed inductively via a finite set of _base types_ composed with
*instructions* (`inst`) and *quantifiers* (`q`) products. Instructions and quantifiers form the carrier sets of two
independent https://en.wikipedia.org/wiki/Ring_(mathematics)[rings] with unity whose direct product forms the
mm-ADT *type ring* and is the subject of study in https://zenodo.org/record/2565243[stream ring theory] (SRT).

\[ \texttt{type} = \texttt{inst} * \texttt{q} \]

NOTE: In stream ring theory, instructions are called _functions_ and quantifiers are called _coefficients_.
A function-coefficient pair is called a _stream_. The equivalence highlights the fact that mm-ADT types are referents
to streams of objects (i.e. https://en.wikipedia.org/wiki/Multiset[multi-sets] or bags).

An informative, yet non-compiling type is presented below in pseudo-`mmlang` notation. The expression highlights the
two primary components of an mm-ADT type: _signature_ and _definition_.

[source]
----
range{q}<=domain{q}[inst]{q}[bran->ch|ing->inst][allows,[nesting,[types]]
|_________________||____________________________________________________|
  type signature                     type definition
----

==== Type Signatures

[source]
----
range{q}<=domain{q}
----

Every mm-ADT type can be generally understood as a function that maps an `obj` of one type to an `obj` of another (potentially
equivalent) type. A *type signature* specifies the source and target of this mapping.

. *Domain*: An mm-ADT type composed of an identity instruction and a quantifier.
. *Range*: An mm-ADT type composed of an identity instruction and a quantifier.

There are 6 *identity instructions* in mm-ADT: `bool`, `int`, `real`, `str`, `lst`, and `rec`. Each is associated with a
base type specified outside the mm-ADT VM within the context of the executing environment. For instance, if an mm-ADT
VM is implemented on the JVM, then `int` is an identity function over `java.math.BigInteger`. The semantics of quantification
varies depending on the user's chosen quantifier ring, but in general, the intuition is that the quantifier denotes the "number"
of `objs` being referred to by the type.

[source]
----
mmlang> int{1}                <1>
==>int
mmlang> int<=int              <2>
==>int
mmlang> int{5}                <3>
==>int{5}
mmlang> int{0,5}              <4>
==>int{0,5}
mmlang> int{0,5}<=int{0,5}    <5>
==>int{0,5}
----
<1> In most programming languages, a value can be typed `int` as in `val x:int`. Such
https://en.wikipedia.org/wiki/Declaration_(computer_programming)[declarations] state that the value referred to by `x`
is a _single_ element within the set of integers. The concept of a "single element" is captured in mm-ADT via quantification,
where when the quantifier is the https://en.wikipedia.org/wiki/Unit_(ring_theory)[unit] of the underlying quantifier ring,
then it is simply not displayed in `mmlang`.
<2> An mm-ADT `int` is a https://en.wikipedia.org/wiki/NOP_(code)[no-op] identity instruction on the set of integers.
Given an integer, `int` returns the integer. In `mmlang`, when the domain and range are the same, the `<=` and repeated
type are not displayed.
<3> An mm-ADT type always refers to an unordered https://en.wikipedia.org/wiki/Multiset[multi-set] (or bag) of elements
known as a _stream_. `int{5}` is a type referring to 5 integers (with repeats possible). As a point of comparison,
`int` denotes a stream containing a single integer. This is why `int` is syntactic sugar for `int{1}` in `mmlang`.
<4> The quantifier ring can be any ring with unity. In the previous examples, the chosen ring's
https://en.wikipedia.org/wiki/Algebraic_structure[carrier set] was the set of integers. In this example, the
carrier set is two integers and is used to capture uncertainty as
to the number of elements being referred to. `int{0,5}` is a type referring to either 0, 1, 2, 3, 4, or 5 integers.
<5> This example emphasizes the point that every mm-ADT type is ultimately a function with a quantified domain and a
quantified range.

==== Type Definition

mm-ADT type signatures specify the base type and quantity of the types domain and range.
Further specification of the nature of the type's referent values is accomplished
via the *type definitions*. The following mm-ADT type is a
https://en.wikipedia.org/wiki/Refinement_type[refinement type] -- it provides further
constraint/refinement to `int`. In particular, it is the mm-ADT definition of a natural number in \$\mathbb{N}\$.

[source]
----
int[is,[gte,0]]
   ||_||_____||
   |op   arg  |
   |__________|
   instruction
----

The structure `[is,[gte,0]]` is an *instruction* with a single argument. mm-ADT instruction opcodes denote specific operations
explicitly implemented by the mm-ADT virtual machine. The set of all mm-ADT instructions forms the
machine's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture].

A type is transformed into another type via an instruction application. Every instruction is able to operate on both
types and values. In this way, instruction application on types yields program _compilation_ and instruction application
on values yields _evaluation_. The compilation of a type produces a type, where quantification and domain/range specifications
are inferred when unspecified by the user.

[source]
----
mmlang> int[is,[gte,0]]                      <1>
==>int{?}<=int[is,bool<=int[gte,0]]          <2>
mmlang> 6 int{?}<=int[is,bool<=int[gte,0]]
==>6                                         <3>
mmlang> -6 int{?}<=int[is,bool<=int[gte,0]]  <4>
mmlang>
----
<1> A base type composed with an instruction/quantifier pair, where the quantifier is not displayed as it's the unit
of the quantifier ring -- `{1}`.
<2> A compiled type that maps a single integer to zero or one integers. If the internal `bool<=int[gte,0]` type yields
`true`, then an `int{1}`, else `int{0}`.
<3> The type maps the positive integer `6{1}` to `6{1}` (_some_).
<4> The type maps the negative integer `-6{1}` to `-6{0}` (_none_).

Any `obj` with the the quantifier ring's additive identity (`zero`) is not displayed by `mmlang`
and can be safely garbage collected by the mm-ADT VM at anytime throughout a non-reducing computation without altering
the semantics of the computation.

===== The Instruction Ring

If `<A,+,*>` is a ring with `A` the carrier set, `0` the additive identity, `1` the multiplicative identity, and `a,b,c,...,0,1` in `A`, then the ring must obey the itemized axioms and benefit from the deductions that yield the common implications and equalities.

.The Ring Axioms and Useful Deductions
|===
|Ring Axioms                        |Popular Entailments

|`(a + b) + c = a + (b + c)`        |`a + b = a + c => b = c`
|`0 + a = a + 0 = a`                |`a + b = 0 => a = -b & b = -a`
|`a - a = a + (-a) = 0`             |`-(a+b) = (-a) + (-b)`
|`a + b = b + a`                    |`-(-a) = a`
|`(a * b) * c = a * (b * c)`        |`a*0 = 0 = 0*a`
|`1 * a = a * 1 = a`                |`a * (-b) = -a * b = -(a * b)`
|`(a + b) * c = (a * c) + (b * c)`  |`(-a) * (-b) = a * b`
|`a * (b + c) = (a * b) + (a * c)`  |
|===

In mm-ADT, the carrier set of the instruction ring is the set of all instructions, where `*` is _serial composition_,
`+` is _parallel composition_,

* the `0`-element is `x{0}<=x[none]` and
* the `1`-element is `x<=x[id]`.

As an example, the types `int[plus,10]` and `bool<=int[gt,5]` can be combined via serial and/or parallel composition.

[source]
----
int[plus,10] * bool<=int[gt,5]   ==   bool<=int[plus,10][gt,5]
int[plus,10] + bool<=int[gt,5]   ==    obj<=int[branch,[plus,10],[gt,5]]
----

All serial and parallel compositions are https://en.wikipedia.org/wiki/Associative_property[associative] except for
those that use instructions from the `inst` sub-ring: _the reduce near-ring_ (discussed later).
Finally, the https://en.wikipedia.org/wiki/Distributive_property[distributivity] of multiplications over addition
is made apparent via:

[source,Delphi]
----
[plus,10] * ([gt,5] + [lt,2])     ==   [plus,10][gt,5] + [plus,10][lt,2]
([plus,10] + [mult,5]) * [gt,7]   ==   [plus,10][gt,7] + [mult,5][gt,7]
----

The above expressions have a diagrammatic representation where the lines are streams of `objs` that are being operated on by the `insts` they meet along the way.
Whenever the diagram branches, the `obj` at the branch is cloned, taking *both* branches.

[ditaa,"inst-left-distributivity",align="center"]
....

             /--[gt,5]--\                /-[plus,10]--[gt,5]-\
             |          |                |                   |
--[plus,10]--+          +-->   <--->   --+                   +-->
             |          |                |                   |
             \--[lt,2]--/                \-[plus,10]--[lt,2]-/
....

[ditaa,"inst-right-distributivity",align="center"]
....
  /--[plus,10]--\                        /-[plus,10]--[gt,7]-\
  |             |                        |                   |
--+             +--[gt,7]-->   <--->   --+                   +-->
  |             |                        |                   |
  \--[mult,5]---/                        \-[mult,5]---[gt,7]-/
....

===== The Quantifier Ring

In the set-theoretic interpretation of types, a type denotes a set in *Set*.
A set does not contain repeated elements.
A _stream_ generalizes a set.
A stream is an unordered collection of `objs` of varying cardinality (a multi-set, or bag).
In mm-ADT, `int` is shorthand for `int{1}`--a single integer.
This is analogous to other languages, where when `int` is used to define a value, it is referring to a single integer from the set of all integers--e.g., `val answer:int = 42`.
Where mm-ADT differs from other languages is that `bool{42}` is a type denoting `42` boolean values.
All `mmlang` expressions within `{ }` operate on the mm-ADT VM's *_quantifier ring_* (w/ unity).
Any `obj` that supports `+`/`*`/`0`/`1` and the axioms governing their composition is supported by mm-ADT.
In mm-ADT, types can be specified to an as accurate or fuzzy degree as computationally and conceptually possible.

Typically, the quantifier of choice for most applications is the `int` ring (or `int` range ring -- `{2,13}`).
Common programming concepts that are usually captured by typeclasses or functors (via
https://en.wikipedia.org/wiki/Lift_(mathematics)[lifting]) are expressed in mm-ADT via quantification.

[source]
----
int                          // a single int (just/some)
int{?}<=int[is,[gt,0]]       // 0 or 1 int   (maybe/option)
int{0}<=int[is,false]        // 0 ints       (none)
int{4}<=int{2}[[id]+[id]]    // 4 ints
int{*}<=[=db][get,'costs']   // 0 or more ints
----

NOTE: `{?}` is shorthand for `{0,1}`, `{+}` for `{1,+infty}`, `{*}` for `{0,+infty}`, and ` ` (nothing) for `{1}`.

The type system of mm-ADT is characterized by a particular formulation of the https://en.wikipedia.org/wiki/Product_ring[direct product of rings]
over the _quantifier_ and _instruction_ rings.
The direct product of these two rings is a ring itself.
Thus, mm-ADT's types are founded on ring theory whose operations are associative w/ identities and therefore,
also form a category.

=== The Type Graph and Commutative Diagram

The mm-ADT *type graph* is composed of _type vertices_ connected by _instruction edges_ referring to a single instruction
that distinguishes them while ensuring that the https://en.wikipedia.org/wiki/Diagram_(category_theory)[categorical diagram]
isomorphic to the type graph https://en.wikipedia.org/wiki/Commutative_diagram[commutes]. In the example graph/diagram
below, a type equivalence is specified via the `[id]`-instruction edge/arrow between `int[plus,10]` and `int[plus,2][plus,8]`.

[ditaa,"type-graph",align="center"]
----
   /---[plus,2]------>int[plus,2]---[plus,8]-->int[plus,2][plus,8]
   |
   |                                                   ^
   |                                                   |
int+---[plus,10]----->int[plus,10]<-------=[id]=-------+
   |
   |
   |
   \--[is,[gte,0]]--->int[is,[gte,0]]
----

Every path through the graph specifies a particular mm-ADT type construction, where an mm-ADT *program* is simply
a type denoted by a terminal vertex. Thus, every mm-ADT program is an mm-ADT type. There exists an mm-ADT
canonical type graph derived by from the previous type graph via a
https://en.wikipedia.org/wiki/Forgetful_functor[forgetful functor], where the vertices
denote the 6 base types and the edges denote
https://en.wikipedia.org/wiki/Endomorphism[endomorphisms] of the base type
monoid or https://en.wikipedia.org/wiki/Homomorphism[homomorphisms] between two type monoids.

[ditaa,"canonical-type-graph",align="center"]
----
                /---[plus,2]
                |      |
                |      |
                |      |
                v /----/
                  |
    [plus,10]---int---[is,[gte,0]]
        |                 |
        |       ^ ^       |
        |       | |       |
        \-------/ \-------/


----




==== Common Type Classifications in mm-ADT's Type Theory

mm-ADT types differ from convention in that they serve to denote:

* *canonical types*: sets of elements denoted as `int` or `str`, etc.
* *refined types*: constraints on the canonical set types such as `nat<=int[is,[gt,0]]`
* *quantified types*: specifying the cardinality of a set via quantification `int{0,5}` (a type of 0 to 5 `int` values).
* *dependent types*:
* *translating types*: specify a mapping from a domain set of elements to a range set of elements as in `int[plus,2]`.
* *recursive types*:

=== Values

There are only two kinds of structures in mm-ADT: _values_ and _types_.
Values are the elements of standard data type sets such as:

[source,Delphi]
----
mmlang> 45[plus,5][plus,[mult,2]]
==>150
mmlang> 'a','b','c'[fold,'seed','',[plus,str<seed>]]
==>'abc'
mmlang> 1,2,3[plus,2]<x>[plus,3]<y>[as,rec['a':int<x>,'b':int<y>]]
==>['a':3,'b':6]
==>['a':4,'b':7]
==>['a':5,'b':8]
mmlang> ['a':['b':['c':['d':0]]]]
==>['a':['b':['c':['d':0]]]]
mmlang> ['a':['b':['c':['d':0]]]].a.b.c.d
==>0
mmlang> .a
==>[get,'a']
----


=== Model Categories and their Functors
////
An mm-ADT _model_ specifies relationships between a set of types within a https://en.wikipedia.org/wiki/Domain_of_discourse[_domain of discourse_].
These relationships are https://en.wikipedia.org/wiki/Path_(topology)[path equations] that specify semantic equivalences between types.
There are two general classes of models:

. *Category*: A category model has `ctype` and `type` mappings to other `ctypes` and `types` within the category.
. *Functor*: A functor model maps `ctypes` and `types` from one category model to a `ctypes` and `types` in another category model.

Every mm-ADT model excluding instructions from the reduce near-ring, forms a https://en.wikipedia.org/wiki/Category_(mathematics)[category], where
the category's _objects_ are the canonical types (`ctypes`) and the _arrows_ are types that span the canonicals.
mm-ADT models are defined via types that are constructed via the instruction ring where both `+` and `*` are associative
and the `[id]` instruction serves as the identity as in `int<=int[id]`.

A _model_ is a `rec` that specifies how a "left-hand side" (LHS) type maps to a "right-hand side" (RHS) type.
Both object and arrow morphisms are captured in this structure.
The model below is a _functor model_ in that is specifies how to move from the category of `int` to the category of `nat`.

[source]
----
rec[
  int<=int[is,[gte,0]] -> nat,
  int[plus,[id]]       -> nat[mult,2]]
----

The above model is diagrammed below where object morphisms are solid lines and the arrow morphism is the dotted line.

[ditaa,"int-nat-functor",align="center"]
....
         int---[plus,[id]]--->int

           |         |          |
           |         |          |
int[is[gte,0]]       :         int[is[gte,0]]
           |         |          |
           v         v          v

         nat-----[mult,2]---->nat
....

[source]
----
mmlang> :model clear
mmlang> :model rec[int<=int[is>=0] -> nat]
mmlang> :model rec[int + [id] -> nat * 2]
mmlang> :model
int ->
	int[is,bool<=int[gte,0]] -> nat
	int[plus,int[id]] -> nat<=int[is,bool<=int[gte,0]][mult,2]
mmlang> 32
==>nat:32
mmlang> 32[plus,[id]]
==>nat:64
mmlang> int[plus,[id]][explain]
==>str<=[start,'
nat<=int[is,bool<=int[gte,0]][mult,2]
instruction             domain      range    state
---------------------------------------------------
[is,bool<=int[gte,0]]    int    =>   int{?}
 [gt,0]                  int   =>    bool
[mult,2]                nat    =>   nat
']
mmlang>
----
////
////
A complex type definition is provided below that captures a large number of the mm-ADT type constructs.

[source]
----
int<=int{2}<x>[plus,10]<y>[is.<10 -> <x>
                          |is.<20 -> <y>
                          |int    -> <x>+<y>][count]
----

.mmlang Language Structures
[cols="75,1,200"]
|===
|Classification          |`mmlang` |Description

|`obj` instruction       |`[ ]`    |The bulk of instructions operate on `objs`.
|traverser instruction   |`< >`    |Traversers are independent computational contexts that can be programmed.
|quantifiers             |`{ }`    |Every `obj` has a quantity as specified by the associated algebraic ring w/ unity.
|branching instructions  |`[->]`   |A `rec` type is used for guarded branching.
|domain/range specifies  |`<=`     |Every type has a domain and a range. Classic types have are endomorphisms.
|===
////

== Storage Structures

== Processor Structures

== Reference Guide

=== Instructions

==== Branch Instructions

===== [choose]

```
y<=x[choose,y<=x:type,(y<=x:type)*]
```

==== Filter Instructions

===== [is]

```
obj<=obj[is,bool]
```

`[is]` is the canonical filter instruction.

```
x:obj[is,y:bool] = [ y[eq,true]  -> x
                   | y[eq,false] -> x[q,0] ]
```

```
mmlang> 6,42[is,true]
==>6
==>42
mmlang> 6,42[is,false]
mmlang> 6,42[is,[a,int]]
==>6
==>42
mmlang> 6,42 is[a,int]
==>6
==>42
mmlang> 6,42[is,[gt,10]]
==>42
mmlang> 6,42[is,[lt,10]]
==>6
mmlang> 6,42[is>10]
==>42
mmlang> 6,42 is>10
==>42
mmlang> int{2}[is>10]
==>int{0,2}<=int{2}[is,bool{2}<=int{2}[gt,10]]
```

==== Map Instructions

===== [a]

```
bool<=obj[a,type]
```

===== [and]

```
bool<=bool[and,bool]
```

===== [eq]

```
bool<=obj[as,obj]
```

===== [get]

```
y <= rec[x:y][get,x]
```

===== [gte]

```
bool<=x[gte,x:ord]
```

===== [gt]

```
bool<=x[gt,x:ord]
```

===== [id]

```
obj<=obj[id]
```

===== [lte]

```
bool<=x[lte,x:ord]
```

===== [lt]

```
bool<=x[lt,x:ord]
```

===== [map]

```
x<=obj[map,x:type]
```

===== [mult]

```
x<=x[mult,x:mmonoid]
```

===== [neg]

```
x<=x[neg,x:pgroup]
```

===== [one]

```
x<=x:mmonoid[one]
```

===== [or]

```
bool<=bool[or,bool]
```

===== [plus]

```
x<=x[plus,x:pmonoid]
```

===== [q]

```
ring<=obj{ring}[q]
```

===== [zero]

```
x<=x:pmonoid[one]
```

==== Model Instructions

===== [as]

```
x<=obj[as,x:type]
```

==== Reduce Instructions

===== [count]

```
ring:x<=obj{ring:x}[count]
```

===== [fold]

==== SideEffect Instructions

===== [error]

```
obj<=obj[error,str]
```

==== Traverser Instructions

===== [explain]

```
str<=type[explain]
```

===== [from]

```
y<=obj<x:y>[from,x]
```

===== [to]

```
y<x:y><=y[to,x]
```
