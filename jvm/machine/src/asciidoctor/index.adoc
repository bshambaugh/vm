= mm-ADT: A Multi-Model Abstract Data Type
Marko A. Rodriguez <marko@rredux.com>
:project-version:
:icons: font
:toc: left
:toclevels: 5
:doctype: book
:docinfo: shared-head
:stem: latexmath
:favicon: ./images/favicon.ico
:source-highlighter: coderay
:source-language: Delphi

//\[
//\int_0^1 x^n dx = \frac{1}{n+1}
//\]

image::images/mm-adt-logo.png[mm-ADT Logo,float="left",width=150]

http://mm-adt.org[mm-ADT] is a dual licensed https://www.gnu.org/licenses/agpl-3.0.txt[AGPL3]/commercial open source project that offers software engineers, computer scientists, mathematicians, and others in the software industry a royalty-based OSS model.
The Turing Complete mm-ADT virtual machine (VM) integrates disparate data technologies via algebraic composition, yielding _synthetic data systems_ that are tailored to the space/time constraints of the problem at hand.
As an economic model, each integration point offers the respective development team access to the revenue stream generated by the commercial organizations leveraging mm-ADT in their products.


== Language, Storage, and Processor

The mm-ADT VM has three primary integration points.

* `LanguageProvider`: Language developers can design custom language or develop parsers for existing languages that compile to mm-ADT VM bytecode (binary) or unicode (`mmlang` encoding).
All mm-ADT languages integrate with the mm-ADT console.
* `StorageProvider`: Storage systems can be integrated with mm-ADT. mm-ADT's flexible data model and type system comfortably support key/value stores, document stores, wide-column stores, graph stores, relational stores, and other novel or hybrid forms such as hypergraphs and docugraph systems.
* `ProcessorProvider`: Processors are any push- or pull-based execution engines.
Processors are responsible for driving the the mm-ADT VM's distributed traverser algorithm on a single-machine in-memory, multi-threaded, distributed near-time, all the way up to cluster-oriented processors for batch analytics.

The mm-ADT VM enables the intermingling of any language, any storage system, and any processor that can faithfully implement the core language semantics (types and values), processor semantics (monadic traversers), and/or storage semantics (streams of atomic and composite data structures).

=== The mm-ADT Console

The mm-ADT VM is packaged with a https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop:[REPL] console that supports any mm-ADT language.
The default language is `mmlang`.

```text
~/software/mm-adt/vm/jvm bin/mmadt.sh
                                _____ _______
                           /\  |  __ |__   __|
 _ __ ___  _ __ ___ _____ /  \ | |  | | | |
| '_ ` _ \| '_ ` _ |_____/ /\ \| |  | | | |
| | | | | | | | | | |   / ____ \ |__| | | |
|_| |_| |_|_| |_| |_|  /_/    \_\____/  |_|
                                 mm-adt.org
mmlang>
```

`mmlang` is in 1-to-1 correspondence with the storage and processing architecture of the mm-ADT VM. As such, `mmlang`
has an assembly language look-and-feel.
Fortunately, the mm-ADT VM was designed to easily support other programming and query languages via the it's `LanguageProvider` interface.
Any language that implements `LanguageProvider` can be used in the mm-ADT console.
Furthermore, mm-ADT _models_ can be shared between languages.

```
mmlang> 1
==>1
mmlang> +2
==>[plus,2]
mmlang> 1+2
==>3
mmlang> 1[plus,2]
==>3
```

== Language Structures

=== Types

mm-ADT types are constructed using a small collection of modifiers.
These are written below within the ascii-structure.

```
range{q}<=domain{q}[inst]{q}[bran->ch|ing->inst][with[nesting]]
```

A complex type definition is provided below that captures a large number of the mm-ADT type constructs.

```
int<=int{2}<x>[plus,10]<y>[is.<10 -> <x>
                          |is.<20 -> <y>
                          |int    -> <x>+<y>][count]
```

.mmlang Language Structures
[cols="75,1,200"]
|===
|Classification          |`mmlang` |Description

|`obj` instruction       |`[ ]`    |The bulk of instructions operate on `objs`.
|traverser instruction   |`< >`    |Traversers are independent computational contexts that can be programmed.
|quantifiers             |`{ }`    |Every `obj` has a quantity as specified by the associated algebraic ring w/ unity.
|branching instructions  |`[->]`   |A `rec` type is used for guarded branching.
|domain/range specifies  |`<=`     |Every type has a domain and a range. Classic types have are endomorphisms.
|===

==== Type Composition and the Instruction Ring

The fundamental base types of mm-ADT are:

* `bool`: two value boolean set containing `true` and `false`.
* `int`: an integer set including positive and negative values (overflow prevention via dynamic bit expansion).
* `real`: a decimal set including positive and negative values (overflow prevention via dynamic bit expansion).
* `str`: the set of all Unicode strings.
* `rec`: a key/value structure supporting arbitrary key and value types.
* `lst`: an ordered list of values support tuple and inductive applications.
* `inst`: an instruction is a `str` opcode and an ordered list of arguments

The referent denoting that union of all these types is `obj`.
Thus, `true` (`bool`), `42` (`int`), and `['a':1]` (`rec`) are in `obj`.

A type is built from a _canonical type_ (called the _domain_) by composing instructions drawn from the set `inst`. `inst`
is the carrier set of the mm-ADT *_instruction ring_* (an https://en.wikipedia.org/wiki/Ring_%28mathematics%29:[algebraic ring with unity]).
Serial composition is multiplication (`\*`) and parallel composition is addition (`+`).
If `<A,+,*>` is a ring with `A` the carrier set, `0` the additive identity, `1` the multiplicative identity, and `a,b,c,...,0,1` in `A`, then the ring must obey the itemized axioms and benefit from the deductions that yield the common implications and equalities.

.The Ring Axioms and Useful Deductions
|===
|Ring Axioms                        |Popular Entailments

|`(a + b) + c = a + (b + c)`        |`a + b = a + c => b = c`
|`0 + a = a + 0 = a`                |`a + b = 0 => a = -b & b = -a`
|`a - a = a + (-a) = 0`             |`-(a+b) = (-a) + (-b)`
|`a + b = b + a`                    |`-(-a) = a`
|`(a * b) * c = a * (b * c)`        |`a*0 = 0 = 0*a`
|`1 * a = a * 1 = a`                |`a * (-b) = -a * b = -(a * b)`
|`(a + b) * c = (a * c) + (b * c)`  |`(-a) * (-b) = a * b`
|`a * (b + c) = (a * b) + (a * c)`  |
|===

In mm-ADT, the carrier set is the set of all instructions `inst` where:

* the `0`-element of `inst` is `obj{0}<=obj[none]` and
* the `1`-element of `inst` is `obj<=obj[id]`.

As an example, the instructions `[plus,10]` and `[gt,5]` can be combined via serial and/or parallel composition.

```
int<=int[plus,10] * bool<=int[gt,5]   ==   bool<=int[plus,10][gt,5]
int<=int[plus,10] + bool<=int[gt,5]   ==    obj<=int[branch,[plus,10],[gt,5]]
```

All serial and parallel compositions are https://en.wikipedia.org/wiki/Associative_property[associative] except for those that use instructions from the `inst` sub-ring: _the reduce near-ring_ (discussed later).
Finally, the
https://en.wikipedia.org/wiki/Distributive_property[distributivity] of multiplications over addition is made apparent via:

```Delphi
[plus,10] * ([gt,5] + [lt,2])     ==   [plus,10][gt,5] + [plus,10][lt,2]
([plus,10] + [mult,5]) * [gt,7]   ==   [plus,10][gt,7] + [mult,5][gt,7]
```

The above expressions have a diagrammatic representation where the lines are streams of `objs` that are being operated on by the `insts` they meet along the way.
Whenever the diagram branches, the `obj` at the branch is cloned, taking *both* branches.

[ditaa,"inst-left-distributivity",align="center"]
....

             /--[gt,5]--\                /-[plus,10]--[gt,5]-\
--[plus,10]--+          +-->   <--->   --+                   +-->
             \--[lt,2]--/                \-[plus,10]--[lt,2]-/
....

[ditaa,"inst-right-distributivity",align="center"]
....
  /--[plus,10]--\                        /-[plus,10]--[gt,7]-\
--+             +--[gt,7]-->   <--->   --+                   +-->
  \--[mult,5]---/                        \-[mult,5]---[gt,7]-/
....

==== Type Quantification and the Quantifier Ring

Typically, a type denotes a set of elements.
A set is a non-repeating collection of said elements.
A _stream_ generalizes a set.
A stream is an unordered collection of `objs` of varying cardinality (a multi-set, or bag).
In mm-ADT, `int` is shorthand for `int{1}`--a single integer.
This is analogous to other languages, where when `int` is used to define a value, it is referring to a single integer from the set of all integers--e.g., `val answer:int = 42`.
Where mm-ADT differs from other languages is that `bool{42}` is a type denoting `42` boolean values.
All
`mmlang` expressions within `{ }` operate on the mm-ADT VM's *_quantifier ring_* (w/ unity).
Any `obj` that supports
`+`/`*`/`0`/`1` and the axioms governing their composition is supported by mm-ADT. In mm-ADT, types can be specified to an as accurate or fuzzy degree as computationally and conceptually possible.

Typically, the quantifier of choice for most applications is the `int` ring (or `int` range ring -- `{2,13}`).
Common programming concepts that are usually captured by typeclasses or functors (via lifting) are expressed in mm-ADT via quantification.

[source]
----
int                          // a single int (just/some)
int{?}<=int[is,[gt,0]]       // 0 or 1 int   (maybe/option)
int{0}<=int[is,false]        // 0 ints       (none)
int{4}<=int{2}[[id]+[id]]    // 4 ints
int{*}<=[=db][get,'costs']   // 0 or more ints
----

NOTE: `{?}` is shorthand for `{0,1}`, `{+}` for `{1,+infty}`, `{*}` for `{0,+infty}`, and ` ` (nothing) for `{1}`.

The type system of mm-ADT is characterized by a particular formulation of the https://en.wikipedia.org/wiki/Product_ring[direct product of rings]
over the _quantifier_ and _instruction_ rings.
The direct product of these two rings is a ring itself.
Thus, mm-ADT's types are founded on ring theory.

[source]
----
mmlang> int
==>int                                               // equivalent to int{1}<=int{1}
mmlang> int[plus,2]
==>int[plus,2]                                       // equivalent to int<=int[plus,2]
mmlang> int[plus,2][is,[gt,3]]
==>int{?}<=int[plus,2][is,bool<=int[gt,3]]           // the [is]-filter and uncertainty
mmlang> int[plus,2][is,[gt,3]][lte,100]
==>bool{?}<=int[plus,2][is,bool<=int[gt,3]][lte,100] // moving from int to bool
----

==== Type Gradient

mm-ADT types differ from convention in that they serve to denote:

* *canonical types*: sets of elements denoted as `int` or `str`, etc.
* *refined types*: constraints on the canonical set types such as `nat<=int[is,[gt,0]]`
* *quantified types*: specifying the cardinality of a set via quantification `int{0,5}` (a type of 0 to 5 `int` values).
* *dependent types*:
* *translating types*: specify a mapping from a domain set of elements to a range set of elements as in `int[plus,2]`.
* *recursive types*:

=== Values

There are only two kinds of structures in mm-ADT: _values_ and _types_.
Values are the elements of standard data type sets such as:

[source,Delphi]
----
mmlang> 45[plus,5][plus,[mult,2]]
==>150
mmlang> 'a','b','c'[fold,'seed','',[plus,str<seed>]]
==>'abc'
mmlang> 1,2,3[plus,2]<x>[plus,3]<y>[as,rec['a':int<x>,'b':int<y>]]
==>['a':3,'b':6]
==>['a':4,'b':7]
==>['a':5,'b':8]
mmlang> ['a':['b':['c':['d':0]]]]
==>['a':['b':['c':['d':0]]]]
mmlang> ['a':['b':['c':['d':0]]]].a.b.c.d
==>0
mmlang> .a
==>[get,'a']
----

=== Model Categories and their Functors

An mm-ADT _model_ specifies relationships between a set of types within a https://en.wikipedia.org/wiki/Domain_of_discourse[_domain of discourse_].
These relationships are https://en.wikipedia.org/wiki/Path_(topology)[path equations] that specify semantic equivalences between types.
There are two general classes of models:

. *Category*: A category model has `ctype` and `type` mappings to other `ctypes` and `types` within the category.
. *Functor*: A functor model maps `ctypes` and `types` from one category model to a `ctypes` and `types` in another category model.

Every mm-ADT model excluding instructions from the reduce near-ring, forms a https://en.wikipedia.org/wiki/Category_(mathematics)[category], where
the category's _objects_ are the canonical types (`ctypes`) and the _arrows_ are types that span the canonicals.
mm-ADT models are defined via types that are constructed via the instruction ring where both `+` and `*` are associative
and the `[id]` instruction serves as the identity as in `int<=int[id]`.

A _model_ is a `rec` that specifies how a "left-hand side" (LHS) type maps to a "right-hand side" (RHS) type.
Both object and arrow morphisms are captured in this structure.
The model below is a _functor model_ in that is specifies how to move from the category of `int` to the category of `nat`.

```
rec[
  int<=int[is,[gte,0]] -> nat,
  int[plus,[id]]       -> nat[mult,2]]
```

The above model is diagrammed below where object morphisms are solid lines and the arrow morphism is the dotted line.

[ditaa,"int-nat-functor",align="center"]
....
         int---[plus,[id]]--->int

           |         |          |
           |         |          |
int[is[gte,0]]       :         int[is[gte,0]]
           |         |          |
           v         v          v

         nat-----[mult,2]---->nat
....

[source]
----
mmlang> :model clear
mmlang> :model rec[int<=int[is>=0] -> nat]
mmlang> :model rec[int + [id] -> nat * 2]
mmlang> :model
int ->
	int[is,bool<=int[gte,0]] -> nat
	int[plus,int[id]] -> nat<=int[is,bool<=int[gte,0]][mult,2]
mmlang> 32
==>nat:32
mmlang> 32[plus,[id]]
==>nat:64
mmlang> int[plus,[id]][explain]
==>str<=[start,'
nat<=int[is,bool<=int[gte,0]][mult,2]
instruction             domain      range    state
---------------------------------------------------
[is,bool<=int[gte,0]]    int    =>   int{?}
 [gt,0]                  int   =>    bool
[mult,2]                nat    =>   nat
']
mmlang>
----

== Storage Structures

== Processor Structures

== Instructions

=== Branch Instructions

==== [choose]

```
y<=x[choose,y<=x:type,(y<=x:type)*]
```

=== Filter Instructions

==== [is]

```
obj<=obj[is,bool]
```

`[is]` is the canonical filter instruction.

```
x:obj[is,y:bool] = [ y[eq,true]  -> x
                   | y[eq,false] -> x[q,0] ]
```

```
mmlang> 6,42[is,true]
==>6
==>42
mmlang> 6,42[is,false]
mmlang> 6,42[is,[a,int]]
==>6
==>42
mmlang> 6,42 is[a,int]
==>6
==>42
mmlang> 6,42[is,[gt,10]]
==>42
mmlang> 6,42[is,[lt,10]]
==>6
mmlang> 6,42[is>10]
==>42
mmlang> 6,42 is>10
==>42
mmlang> int{2}[is>10]
==>int{0,2}<=int{2}[is,bool{2}<=int{2}[gt,10]]
```

=== Map Instructions

==== [a]

```
bool<=obj[a,type]
```

==== [and]

```
bool<=bool[and,bool]
```

==== [eq]

```
bool<=obj[as,obj]
```

==== [get]

```
y <= rec[x:y][get,x]
```

==== [gte]

```
bool<=x[gte,x:ord]
```

==== [gt]

```
bool<=x[gt,x:ord]
```

==== [id]

```
obj<=obj[id]
```

==== [lte]

```
bool<=x[lte,x:ord]
```

==== [lt]

```
bool<=x[lt,x:ord]
```

==== [map]

```
x<=obj[map,x:type]
```

==== [mult]

```
x<=x[mult,x:mmonoid]
```

==== [neg]

```
x<=x[neg,x:pgroup]
```

==== [one]

```
x<=x:mmonoid[one]
```

==== [or]

```
bool<=bool[or,bool]
```

==== [plus]

```
x<=x[plus,x:pmonoid]
```

==== [q]

```
ring<=obj{ring}[q]
```

==== [zero]

```
x<=x:pmonoid[one]
```

=== Model Instructions

==== [as]

```
x<=obj[as,x:type]
```

=== Reduce Instructions

==== [count]

```
ring:x<=obj{ring:x}[count]
```

==== [fold]

=== SideEffect Instructions

==== [error]

```
obj<=obj[error,str]
```

=== Traverser Instructions

==== [explain]

```
str<=type[explain]
```

==== [from]

```
y<=obj<x:y>[from,x]
```

==== [to]

```
y<x:y><=y[to,x]
```
