:imagesdir: ./images/language
:subs: non

== Language Structures

image::compiling-languages.png[float="right",width=300]

The mm-ADT VM is written in https://scala-lang.org/[Scala]. It contains a fluent program builder https://en.wikipedia.org/wiki/Application_programming_interface[API] called `mmscala`. Most compiler designers should avoid `mmscala` because direct access to the https://en.wikipedia.org/wiki/Java_virtual_machine[JVM] and the full JDK can create unsafe mm-ADT programs. Instead, `mmlang` should be the target language for most compilers. Moreover, all compilers targeting `mmlang` can be used across different mm-ADT VM implementations.

IMPORTANT: The recommended target language for all higher-level language compilers is `mmlang`.

.Products and Coproducts
****
https://en.wikipedia.org/wiki/Category_theory[Category theory] is the study of structure via manipulations that expose (or generate) other structures. Two important category theoretic concepts used throughout this section are *products* and *coproducts*.

image::product.png[float="left",width=225]

A https://en.wikipedia.org/wiki/Product_(category_theory)[product] is any object defined in terms of it's accessible component objects. That is, from a single object, via \$\pi_n\$ projection morphisms, the product is decomposed into it's constituent parts.

image::coproduct.png[float="right",width=225]

A https://en.wikipedia.org/wiki/Coproduct[coproduct] is any object defined in terms the component objects used to construct it. That is, from many objects, via \$\iota_n\$ injection morphisms, a coproduct can be composed from constituent parts.

Along with these decomposition (and composition) morphisms, there exists an https://en.wikipedia.org/wiki/Isomorphism[isomorphism] between any two products (or coproducts) should they project (or inject) to the same component objects. That is, product and coproduct equality are defined via component equality.
****

=== The Obj

image::obj-type-value-q.png[role=left,padding-left=303,width=280]

Everything that can be denoted in `mmlang` is an `obj`. Within the VM and outside the referential purview of an interfacing language, every `obj` is the product of

. An *object* that is either a *type* or a *value* and
. A *quantifier* specifying the "amount" of objects being denoted.

\[
\texttt{obj} = (\texttt{type} + \texttt{value}) \times \texttt{q}.
\]

image::obj-type-q-value-q.png[float=right,width=450]

This internal structure is well-defined as an https://en.wikipedia.org/wiki/Ring_(mathematics)[algebraic ring]. The ring axioms specify how the internals of an `obj` are related via two binary operators: \$\times\$ and \$\+\$ . One particular axiom states that products both left and right https://en.wikipedia.org/wiki/Product_(category_theory)#Distributivity[distribute] over coproducts. Thus, the previous formula can be rewritten as \[
\texttt{obj} = (\texttt{type} \times \texttt{q}) + (\texttt{value} \times \texttt{q}).
\]
This representation, which is https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to the previous, states two distinct kinds of mm-ADT `objs`: *quantified types* and *quantified values*. This is the *obj meta-model*.

[source]
----
mmlang> int            <1>
==>int
mmlang> 1              <2>
==>1
mmlang> int{5}         <3>
==>int{5}
mmlang> 1{5}           <4>
==>1{5}
mmlang> 'a','b','a'    <5>
==>'a'{2}
==>'b'
----
<1> A single `int` type.
<2> A single `int` value of `1`.
<3> Five `int` types.
<4> Five `1` `int` values.
<5> A _stream_ of `'a'`,`'b'`, and `'a'` `str` values.

==== Types and Values

Many modern programming environments make a sharp distinction between types and values, where each is predominately the focus of either https://en.wikipedia.org/wiki/Compiler[compilation] (types) or evaluation (values). In mm-ADT, instructions operate on both types and values. Two interesting consequences are that compilation is simply running an mm-ADT program with type arguments and when values are applied to types during evaluation, types serve as https://en.wikipedia.org/wiki/Anonymous_function[lambda (or anonymous) functions].

[source]
----   
mmlang> int int[is>0]                 <1>
==>int{?}<=int[is,bool<=int[gt,0]]
mmlang> 5 int[is>0]                   <2>
==>5
mmlang> -1 int[is>0]                  <3>
mmlang>
----
<1> The `int` type is passed to the `int[is>0]`-type to yield an either 0 or 1 `int` (compilation)
<2> The type `[is>0]` serves as a lambda of the form \[ \lambda x = \begin{cases} x & \text{if } x > 0 \\ \emptyset & \text{otherwise.} \end{cases} \]
<3> The type `[is>0]` filtering the `int` value -1.


[width=60]
|===
| Types | Values

| Refer to themselves and values | Refer to themselves
| Generalized values | Specified types
| A non-unit function | A unit function
|===

The continuum between types and values eases many longstanding distinctions in computer science. The table below presents a collection of the more interesting conceptual blurs that are introduced in mm-ADT. The particulars of each will be discussed over the course of this documentation.

.Consequences of Type/Value Unification
[cols="2,2,10"]
|===
|structure A | structure B | unification

|types       | values     | quantifiers expand the cardinality of values and constrain the cardinality of types
|compilation | evaluation | compilations are evaluations with types, where a compilation error is a "runtime compile-time" error.
|AST         | bytecode   | the algebra of type construction relaxes the necessity for different program encodings.
|state       | values     | 'mutable' state are values from historic types contained within the structure of the current type.
|functions   | types      | functions are (dependent) types with value references generated at evaluation.
|programs    | types      | a program is a "complicated" type.
|classical   | quantum    | quantum computing is classical computing with unitary matrix quantifiers.
|canonical   | atomics    | atomic values and canonical types are both "tokens" by which all constructions are built.
|===

=== The Type

An `obj` was previously defined as \[
\texttt{obj} = (\texttt{type} \times \texttt{q}) + (\texttt{value} \times \texttt{q}).
\]

This definition specifies no internal structure to a type or value. If this definition was complete, then types and values would be isomorphic and thus, indistinguishable. This is not the case. Types are defined in terms of other types. Values are not. mm-ADT types are a coproduct, where every type is either a

. *canonical type* (ctype): a base/fundamental type, or a
. *derived type* (dtype): a product of a type and an instruction (`inst`).

The ctypes are https://en.wikipedia.org/wiki/Nominal_type_system[nominal types]. There are five ctypes:

image::type-product.png[float=right,width=295]

. *bool*: denotes the set of booleans -- \$ \mathbb{B} \$.
. *int*: denotes the set of integers -- \$ \mathbb{Z} \$.
. *real*: denotes the set of reals -- \$ \mathbb{R} \$.
. *str*: denotes the set of character strings -- \$ \Sigma^\ast \$.
. *poly*: denotes the set of composites (polynomials) -- \$ \tt{obj}^n \$.

The dtypes are https://en.wikipedia.org/wiki/Structural_type_system[structural types] whose https://en.wikipedia.org/wiki/Recursive_data_type[recursive definition] is ultimately based at a ctype via a chain of instructions (`inst`) that operate on types to yield types. The path back to a type's base ctype is called the type's *trace*. Formally, the type coproduct is defined as

\[
  \begin{split}
    \texttt{type} &=\;& (\texttt{bool} + \texttt{int} + \texttt{real} + \texttt{str} + \texttt{poly}) + (\texttt{type} \times \texttt{inst}) \\
    \texttt{type} &=\;& \texttt{ctype} + (\texttt{type} \times \texttt{inst}) \\
    \texttt{type} &=\;& \texttt{ctype} + \texttt{dtype}, 
  \end{split}
\]

where each component of the coproduct also has a respective quantifier as previously defined for all `objs`.

A dtype has two \$pi\$-projections. The type projection denotes the _domain_ and the instruction projection denotes the _function_, where the type product as a whole, relative to the component projections, is the _range_.
\[
  \begin{split}
    \tt{type} &=\;& (\tt{type} &\;\times\;& \tt{inst}) &\;+\;& \tt{ctype} \\ 
    \text{â€œrange} &=\;& (\text{domain} &\;\text{and}\;& \text{function}) &\;\text{or}\;& \text{base"} 
  \end{split}
\]

The implication of the dtype product is that mm-ADT types are generated https://en.wikipedia.org/wiki/Inductive_type[inductively] by applying instructions from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (`inst`). The application of an `inst` to a type (ctype or dtype) yields a dtype that is a structural expansion of the previous type.

image::ctype-dtype.png[align=center,width=230]

For example, `int` is a ctype denoting a single `int` value from the set of all integers. When the instruction `[is>0]` is applied to `int`, the dtype `int[is>0]` is formed. This dtype is a https://en.wikipedia.org/wiki/Refinement_type[refinement type] that restricts `int` to only those `int` values greater than zero -- i.e., a natural number \$\mathbb{N}^+\$. In terms of the "__range = domain and function__" reading, when `int` (*domain*) is applied to `[is>0]` (*function*), the result is an `int` greater than zero (*range*).

image::int_isgt0.png[align=center,width=260]

The diagram above is a representation of a structure that is important across numerous processes in mm-ADT including type checking, type inference, compiler optimization, garbage collection, and more. It has a name. It's called the program's *type graph*.

image::obj-full.png[float=right,width=320]

The full `obj` structure thus far is diagrammed on the right and some type construction examples are presented in `mmlang` on the left.

[source]
----
mmlang> int                                      <1>
==>int
mmlang> int{2}                                   <2>
==>int{2}
mmlang> int{2}[is>0]                             <3>
==>int{0,2}<=int{2}[is,bool{2}<=int{2}[gt,0]]
----
<1> A ctype denoting a single integer stream.
<2> A ctype denoting a stream with two integers.
<3> A dtype denoting a stream of zero, one, or two integers.

The salient features of a type are captured in the psuedo-`mmlang` expression below, where the three projections are conviently understood as encoding a type's

. *Type signature*: the ctype specification of a type's domain and range (via the \$ \pi_\tt{domai\n} \$ and \$ \pi_\tt{rang\e} \$ projections), and
. *Type definition*: an instruction tree specifying domain `obj` processes (via the \$ \pi_\tt{i\nsts} \$ projection).

image::type-signature-definition.png[align=center,width=650]

==== Type Structure

===== Type Signature

Every mm-ADT type can be generally understood as a function that maps an `obj` of one type to an `obj` of another type. A *type signature* specifies the source and target of this mapping, where the _domain_ is the source type and the _range_ is the target type. Both the domain and range type specifications include a respective quantifier denoted `{q}` in `mmlang`. The general pattern of a type signature is

[source,align=center]
----
range{q}<=domain{q}
----

[cols="5,10"]
|===
|mmlang Expression |Description

a|
[source]
----
mmlang> int{1}
==>int
----
|In most programming languages, a value can be typed `int` as in `val x:int = 10`. Such https://en.wikipedia.org/wiki/Declaration_(computer_programming)[declarations] state that the value referred to by `x` is a _single_ element within the set of integers. The concept of a "single element" is captured in mm-ADT by the `obj` quantifier, where a https://en.wikipedia.org/wiki/Unit_(ring_theory)[unit] quantifier is not displayed in `mmlang`.

a|
[source]
----
mmlang> int<=int
==>int
----
|From the perspective of type-as-function, An mm-ADT `int` is a https://en.wikipedia.org/wiki/NOP_(code)[no-op] on the set of integers. Given any integer, `int` returns that integer. In `mmlang`, when the domain and range are the same, the `\<=` and repeated type are not displayed.

a|
[source]
----
mmlang> int<=bool
error: bool is not an int
----
|Type's that are fully specified by their type signature are always canonical types. Without any instructions, there is no way that this (meaningless) type can map a `bool` to an `int`. 

a|
[source]
----
mmlang> int{5}
==>int{5}
----
|`int{5}` is a type referring to 5 integers (with repeats possible according to stream semantics). As a point of comparison, `int` denotes a stream containing a single integer. This is why `int` is syntactic sugar for `int{1}` in `mmlang`.

a|
[source]
----
mmlang> int{0,5}
==>int{0,5}
mmlang> int{0,5}<=int{0,5}
==>int{0,5}
----
|Quantifiers must be elements from a ring with unity. In the previous examples, the chosen quantifier was the integer ring \$\langle \mathbb{Z},+,\times \rangle\$. In this example, the https://en.wikipedia.org/wiki/Algebraic_structure[carrier set] is two integers and represents uncertainty as to the number of elements being referred to. `int{0,5}` is a type referring to either 0, 1, 2, 3, 4, or 5 integers.
|===

===== Type Definition

Types and values both have a *ground* that exists outside of the mm-ADT VM within the hosting environment (e.g. the JVM). The ground of the mm-ADT value `2` is the JVM primitive `2L` (a Java `long`). The ground of the mm-ADT type `int` is the JVM class `java.lang.Long`. When the instruction `[plus,4]` is applied to the mm-ADT `int` value `2`, a new mm-ADT `int` value is created whose ground is the JVM value `6L`. When `[plus,4]` is applied to the mm-ADT `int` type, a new type is created with the same `java.lang.Long` ground. Thus, the information that distinguishes `int` from `int[plus,4]` is in the remembrance of the instruction that was applied to `int`. For a type, this history is called the *type definition* (and more generally, the *type's trace*).

NOTE: In practice, the string representation of a value is it's ground and the string representation of a type is it's trace.

image::type-value-trace.png[align=center,width=550]

Both types and values exist in a larger graph called the *obj trace graph*. In theory, the complete history of an mm-ADT program from compilation to execution is stored in this graph. However, in practice, the mm-ADT VM removes those traces (particular paths through the graph) that will no longer be needed by mm-ADT program. This process is called *trace removal* and is the mm-ADT equivalent of https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)[garbage collection].

===== Type Quantification

.Quantifier Symbols in mmlang
[width=35%,cols="1,1,2,float=right]
|===
|usage   |sugar  | unsugared

|https://en.wikipedia.org/wiki/Option_type[none]/nothing   |`{0}`  | `{0,0}`
|https://en.wikipedia.org/wiki/Option_type[some]/just      |       | `{1,1}`
|exact          |`{x}`  | `{x,x}`
|least footnote:order[Applicable to quantifier rings with an total order over the carrier.]         |`{x,}` | `{x,max}`
|most footnote:order[]          |`{,x}` | `{min,x}`
|https://en.wikipedia.org/wiki/Option_type[option]/maybe   |`{?}`  | `{0,1}`
|given footnote:order[]         |`{+}`  | `{1,max}`
|any footnote:order[]           |`{*}`  | `{1,max}`
|===

In order to quantify the _amount_ of values denoted by a type, every mm-ADT type has an associated quantifier `q`.
Quantifiers are typically integers, but can be any element from an ordered algebraic ring (e.g. integers, reals in \$ \mathbb{R}, \mathbb{R}^2, \mathbb{R}^3, \ldots, \mathbb{R}^n \$, unitary matrices, etc.).
Moreover, while integer quantifiers signify "amount," other quantifiers such as unitary matrices used to represent a https://en.wikipedia.org/wiki/Wave_function[quantum wave function], "amount" is a less accurate description.

Common programming concepts that are usually captured by typeclasses or functors (via https://en.wikipedia.org/wiki/Lift_(mathematics)[lifting]) are expressed in mm-ADT via quantification.

[source]
----
int                               // a single int   (some)
int{?}<=int[is,[gt,0]]            // 0 or 1 int     (option)
int{0}<=int[is,false]             // 0 ints         (none)
int{4}<=int{2}[branch,[id],[id]]  // 4 ints         (exact)
int{*}<=[=db][get,'people']       // 0 or more ints (any)
----

NOTE: The default quantifier ring of the mm-ADT VM is \[
\langle \mathbb{N}^+ \times \mathbb{N}^+, \ast, + \rangle, \]
where \$(1,1)\$ is the multiplicative identity (unity) and \$(0,0)\$ is the additive identity. The \$\ast\$ and \$ +\$ binary operators are pairwise integer multiplication and addition, respectively. In `mmlang` if an `obj` quantifier is not displayed, then the quantifier is assumed to be the unity of the ring, or `{1,1}`. Moreover, if a single value is provided, it is assumed to be repeated where `{n}` is shorthand for `{n,n}`.

===== Type Trace Graph

Every mm-ADT program is a _type_. Every type is created by a https://en.wikipedia.org/wiki/Type_constructor[type constructor]. The ctypes are degenerate _nullary_ constructors. The dtypes are `n`-ary constructors with their arity being the number of instructions applied to their respective base ctype. The arity is also the path length of the spine of the type's definition within a https://en.wikipedia.org/wiki/Directed_graph[directed labeled graph] called a *type trace graph*.

====== Linear Type Traces

Any type constructed with instructions contain argument values (not types) generates a *linear type trace*.

[source]
----
mmlang> int
==>int
mmlang> int[id]
==>int[id]
mmlang> int[id][gt,0]
==>bool<=int[id][gt,0]
----

====== Nested Type Traces

Any type constructed with instructions that contain an argument type generates a *nested type trace*.

[source]
----
mmlang> int
==>int
mmlang> int[id]
==>int[id]
mmlang> int[id][is,[gt,0]]
==>int{?}<=int[id][is,bool<=int[gt,0]]
mmlang>
----

====== Branching Type Traces

Nested types are examples of _inter-instruction branching_. The more general form is _intra-instruction branching_. Any instruction that forks an `obj` into a `poly` or joins the `objs` of a `poly` are *branch instructions*. They generate *branching type traces*.

A https://en.wikipedia.org/wiki/Tagged_union[*sum type*] (tagged union) is constructed by branching across a `|-poly`.

image::sum-type-constructor.png[width=600,align=center]

[source]
----
mmlang> int~<[int[is>0] | int[neg]]
==>[int{?}<=int[is,bool<=int[gt,0]]|int[neg]]<=int~<[int{?}<=int[is,bool<=int[gt,0]]|int[neg]]
----

In the example above, a `int` is the ctype that is split across two branches via `[choice]` (with a sugar of `~<`). Given an `int` value, that `int` value will either be greater than 0 or it will be negated.  In other words, the type maps an `int` to a coproduct containing it's https://en.wikipedia.org/wiki/Absolute_value[absolute value] as determined either from the first or the second branch.

[source]
----
mmlang> 10<int[is>0] | int[neg]>
==>[10|]
mmlang> -10<int[is>0] | int[neg]>
==>[|10]
----

While both injections of the coproduct contain the same value, their location in the coproduct contains information about the state of the domain `int`. For example, should the coproduct undergo a `[merge]` (with a sugar of `>-`), then the above type yields the same range value for two different `int` domains.

[source]
----
mmlang> 10<int[is>0] | int[neg]>
==>10
mmlang> -10<int[is>0] | int[neg]>
==>10
----

Without the merge, the branch that the incoming `int` took is preserved in the coproduct's `poly` structure and can be inverted.

[source]
----
mmlang> 10<int[is>0] | int[neg]]=[_|[neg]>
==>10
mmlang> -10<int[is>0] | int[neg]]=[_|[neg]>
==>-10
----

==== Type Compilation

Every instruction is able to operate on both types and values. Instructions applied to types is program _compilation_ and instructions applied to values is program _evaluation_.

[cols="10,10"]
|===
|mmlang Expression |Description

a|
[source]
----
mmlang> int[is,[gte,0]]
==>int{?}<=int[is,bool<=int[gte,0]]
----
|A base type composed with an instruction/quantifier pair, where the quantifier is not displayed as it's the unit of the quantifier ring -- `{1}`. The result is a compiled type that maps a single integer to zero or one integers. If the internal `bool\<=int[gte,0]` type yields `true`, then an `int{1}`, else `int{0}`.

a|
[source]
----
mmlang> int int[is,[gte,0]]
==>int{?}<=int[as,int][is,bool<=int[gte,0]]
----
|A type operates on an `int` thus, if supplied "an `int` type", the type operates on it to yield a type. The use of types to process types is a form of compilation generally known as https://en.wikipedia.org/wiki/Abstract_interpretation[abstract interpretation].

a|
[source]
----
mmlang> 6 int{?}<=int[is,bool<=int[gte,0]]
==>6
----
|The type maps the positive integer `6{1}` to `6{1}` (_some_).

a|
[source]
----
mmlang> -6 int{?}<=int[is,bool<=int[gte,0]]
mmlang>
----
|The type maps the negative integer `-6{1}` to `-6{0}` (_none_).
|===

==== Mono Types

An mm-ADT `mono` is the set of all atomic types.

[.small]
[cols="1,3,1,1",width=35%,float=left]
|===
| type | inst                              | 0       |  1

| `bool` | `&&` `\|\|` `-`                 | `false` | `true`
| `int`  | `*` `+` `-` `>` `<` `>=` `\<=`  | `0`     | `1`
| `real` | `*` `+` `-` `>` `<` `>=` `\<=`  | `0.0`   | 1.0
| `str`  | `+` `>` `<` `>=` `\<=`          | `''`    |
|===

'''

===== Bool Type

[source]
----
mmlang> true
==>true
mmlang> true&&false
==>false
mmlang> true[and,false]
==>false
mmlang> true[and,false][neg]
==>true
mmlang> true[and,false][neg][or,false]
==>true
mmlang> bool[and,false][neg][or,false][explain]
==>'
bool[and,false][neg][or,false]

instruction    domain       range  state
-----------------------------------------
[and,false]    bool    =>   bool
[neg]          bool    =>   bool
[or,false]     bool    =>   bool
'
mmlang>
----

===== Int Type
===== Real Type
===== Str Type


==== Poly Types

The elements of the set \$\mathbf{Poly}\$ are https://en.wikipedia.org/wiki/Polynomial[polynomials] denoted `poly`. A `poly` is the composite of:

. *indeterminates*: type `objs` known as variables or symbols,
. *constants*: value `objs` known as constants,
. *binary relations*: the symbols `;` (*andThen*), `,` (*orThen*), and `|` (*xorThen*) used to compose `poly` expressions.

If \$V \subset \mathbf{Obj} \$ are the set of all mm-ADT `obj` values, \$T \subset \mathbf{Obj}\$ the set of `obj` types, \$V \cap \T = \empty\$, then the polynomial \$ \tt{poly} \in \tt{Poly} \$ is
\[
(v_0;t_0),(v_1;t_1),\ldots,(v_n;t_n)
\]
and is denoted, in `mmlang`, as either
[source]
----
[[v0;t0],[v1;t1],...,[vn;tn]]
[[v0;t0]|[v1;t1]|...|[vn;tn]]
----

Every `[v;t]` composition is called a *term*. The terms of a `poly` can be reduced using a _summation operator_  (`,` or `|`) whose general form is
\[
\texttt{obj} = \sum_{i<n} \texttt{v}_i;\texttt{t}_i.
\]

'''

An mm-ADT `poly` has the following uses:

. *Data structures* (_values_): A value-based `poly` is a _determinate polynomial_ (i.e., a polynomial lacking indeterminates).
. *Process structures* (_types_): . The `[split]` instruction clones the incoming `obj` across the `poly` indices and resolves each `obj` clone to an `obj` of the component type's range. For types respecting https://en.wikipedia.org/wiki/No-cloning_theorem[no-clone] axioms, `obj` coefficients are manipulated accordingly to ensure requisite `obj`/anti-`obj` https://en.wikipedia.org/wiki/Creation_and_annihilation_operators[annihilation]. All range `objs` are aggregated into a subsuming type by the `[merge]` instruction. In this manner, a type-based `poly` serves as an \$n\$-ary branch structure whose composition operator and component coefficients provide branch semantics.

mm-ADT provides two convenient type constructors for working with `poly` data structures: `lst` (an `int`-indexed array) and `rec` (an `obj`-indexed array).

===== Data Structures

[source]
----
mmlang> [1,2,3]
==>[1,2,3]
mmlang> [[1;[id]],[2;[id]],[3;[id]]]
==>[[1;_[id]],[2;_[id]],[3;_[id]]]
mmlang> -<[-<[1;[id]]>-,-<[2;[id]]>-,-<[3;[id]]>-]
==>[1,2,3]
----

===== Process Structures

====== Free Poly Monoid

[.small]
[cols="1,1,1,1",width=30%,float=left]
|===
| op       | poly | inst        |  meta

| \$\ast\$ | `;`  | `[compose]` | `[mult]`
| \$+\$    | `,`  | `[branch]`  | `[plus]`
| \$o+\$   | `\|` | `[choose]`  | `[plus]`
|===

An mm-ADT `poly` (https://en.wikipedia.org/wiki/Polynomial[polynomial]) is an element of either a _serial_ (`;`), _parallel_ (`,`), or _choice_ (`|`) https://en.wikipedia.org/wiki/Free_object[free] https://en.wikipedia.org/wiki/Trace_monoid[trace monoid] that is https://en.wikipedia.org/wiki/Adjoint_functors[left-adjoint] to a respective \$langle \tt{obj},\tt{[compose] \rangle\$, \$langle \tt{obj},\tt{[branch]} \rangle\$, or \$langle \tt{obj}, \tt{[cho\ose]} \rangle\$ non-free, reductive monoid. The _nabla functions_, \$\nabla: \text{-poly} \rightarrow \tt{obj} \$, folds a free `poly` structure into an `obj{*}` via the applications of the reducing monoid's operator in `inst` such that
\[
\begin{split}
\nabla^;(\texttt{poly}) &=& \texttt{[compose}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=\prod_{i<n} q_i, \\
\nabla^,(\texttt{poly}) &=& \texttt{[branch}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=\sum_{i<n} q_i, \\
\nabla^|(\texttt{poly}) &=& \texttt{[choose}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=(\min_{i<n}(q_i),\max_{i<n}(q_i)),
\end{split}
\]
where \$\nabla\$ is realized as the https://ncatlab.org/nlab/show/codiagonal[codiagonal] `>-` (i.e. `[merge]`) instruction. the resultant `obj` is quantified within the specified `q` range. This is the general solution to deriving the type quantifier during compilation and can be further refined using instruction semantics. The following diagrams specify three https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms[monoid homomorphisms] that couple the `poly` to `inst` monoids such that the underlying monoidal processes of the mm-ADT VM can be directly manipulated by any mm-ADT language that supports `poly` -- e.g., within `mmlang`.

'''
image::free-monoid-homomorphisms.png[align=center]
'''

Both the `-poly` and \$\langle \tt{obj},- \rangle\$ monoids derive their https://en.wikipedia.org/wiki/Algebraic_structure[carrier sets] from the https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial] set of mm-ADT `objs`. The injective _delta functions_, \$\Delta:\tt{obj} \rightarrow \text{-poly}\$, yield the https://en.wikipedia.org/wiki/Generator_(mathematics)[generators] of the `-poly` monoid's, where
\[
\begin{split}
\Delta^{;}(\texttt{obj}) &=& [\texttt{obj};], \\
\Delta^{,}(\texttt{obj}) &=& [\texttt{obj},], \\
\Delta^{|}(\texttt{obj}) &=& [\texttt{obj}|],
\end{split}
\]
and \$\Delta\$ the https://en.wikipedia.org/wiki/Diagonal_morphism[diagonal] `-<` (i.e. `[split]`) instruction. Likewise, `[compose]`, `[branch]`, and `[choose]` are the instruction representations of the composition of `objs`. If
\[
\begin{split}
U: M \rightarrow \textbf{Set}
\end{split}
\]
maps a monoid to its carrier set, then the diagrams below commute, where the https://en.wikipedia.org/wiki/Universal_property[universal property] of monoid mappings is realized as the "lifted" `poly` syntactic category encoding of the mm-ADT https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture].

image::monoid-homomorphisms.png[align=center]

The following diagrams detail the operational semantics of the mm-ADT VM with respects to the coupling between the corresponding free and reductive monoids. The dashed lines provide a disentangled, parallel (product) view of the respective double-line compositions. Finally, the squiggly line joining the two parallel morphisms in the `|-poly` diagram makes clear that, unlike the branches in `,-poly` these branches are coupled to ensure the proper https://en.wikipedia.org/wiki/Tagged_union[sum type] (disjoint union) semantics of the _either_ https://en.wikipedia.org/wiki/Coproduct[coproduct].

[cols="3,^9"]
|===
| `;-poly`
\[
\left(\Delta^; \circ \left(f \ast g\right) \circ \nabla^; \right)
\]
andThen/compose-chain +
dependent slots +
product +
\$A \ast B \implies C\$
| image:semi-delta-nabla.png[width=455,link=images/language/semi-delta-nabla.png]

| `,-poly`
\[
\left(\Delta^, \circ \left(f+g\right) \circ \nabla^,\right)
\]
copy/clone-branching +
independent slots +
product +
\$A+A \implies 2A\$
| image:comma-delta-nabla.png[width=455,link=images/language/comma-delta-nabla.png]


| `\|-poly`
\[
\left(\Delta^\| \circ \left(f \oplus g\right) \circ \nabla^\|\right)
\]
either/choice-branching +
dependent slots +
coproduct +
\$A \oplus A \implies A\$
| image:pipe-delta-nabla.png[width=455,link=images/language/pipe-delta-nabla.png]
|===

====== Free Ring

The two `;,-poly` monoids serve as components of a https://en.wikipedia.org/wiki/Universal_algebra[universal algebra] that implements the https://zenodo.org/record/2565243[stream ring] algebra -- the foundational algebra of the mm-ADT VM. The two `poly` monoids form a https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] and thus, a syntactic https://en.wikipedia.org/wiki/Free_algebra[free algebra] that enables mm-ADT https://en.wikipedia.org/wiki/Metaprogramming[metaprogramming] by way of a https://en.wikipedia.org/wiki/Ring_homomorphism[ring homomorphism] from the *structural* ` `;,-poly` free ring to the corresponding reductive *procedural* ring such that
\[
;,-\texttt{poly}  \xrightarrow{\;\;\;\nabla^{;}\;\;\;} \langle \texttt{obj},\texttt{[compose][branch]}, \rangle
\]
where the _branch_ component is, in fact, a group with `-<[a{q},a{-q}]>- = obj{0}` and `[branch,a{q},a{-q}] = obj{0}`.
[source]
----
mmlang> -<['a'{2},'a'{-2}]
==>['a'{2},'a'{-2}]
mmlang> -<['a'{2},'a'{-2}]>-
mmlang>
mmlang> [branch,['a'{2},'a'{-2}]]
mmlang>
----


The `|-poly` can be appended to the `;,-poly` ring, where it serves as an https://en.wikipedia.org/wiki/Idempotence[idempotent] variation of the additive group commonly used to denote https://en.wikipedia.org/wiki/Tagged_union[sum types].

.Delta Poly
[.small]
[cols="4,1,9",width=46%,float=left]
|===
| poly op         | mmlang      | example

| `;`-*apply*  | `-<[;]`
a|
[source]
----
mmlang> 6-<[_;_]
==>[6;6]
mmlang> 6-<[_+1;_>6]
==>[7;true]
----
| `,`-*copy*   | `-<[,]`
a|
[source]
----
mmlang> 6-<[_,_]
==>[6,6]
mmlang> 6-<[_>0,_>8]
==>[true,false]
----
| `\|`-*pick*  | `-<[\|]`
a|
[source]
----
mmlang> 6-<[_\|_]
==>[6\|]
mmlang> 6-<[_>0\|_>8]
==>[true\|]
----
|===

.Nabla Poly
[.small]
[cols="4,1,9",width=46%,float=right]
|===
| poly op            | mmlang      | example

| `;`-*return*     | `[;]>-`
a|
[source]
----
mmlang> 6-<[_;_]>-
==>6
mmlang> 6-<[_+1;_>6]>-
==>true
----
| `,`-*merge*      | `[,]>-`
a|
[source]
----
mmlang> 6-<[_,_]>-
==>6{2}
mmlang> 6-<[_>0,_>8]>-
==>true
==>false
----
| `\|`-*coalesce*  | `[\|]>-`
a|
[source]
----
mmlang> 6-<[_\|_]>-
==>6
mmlang> 6-<[_+1\|_>6]>-
==>7
----
|===

'''

In terms of the mm-ADT VMs component architecture, this ring homomorphism maps a *language* to a *processor* through the common communication medium of `objs` provided by *storage*. All mm-ADT compliant components are faithful to `obj` and the stream ring axioms that bind them regardless of their particular ring encoding. In this way, the mm-ADT VM remains agnostic to the specifics of the component implementations and thus, mm-ADT supports the creation of _synthetic data systems_.

image::ring-homomorphisms.png[align=center,width=320]

=== Language Algebras

==== Bicartesian Closed Category

.Initial and Terminal Objects
****
image::initial.png[width=130,float=left]

A category may have an https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial and/or terminal] object.

An *initial object* \$S\$ is the domain of a set of morphism \$S \rightarrow E_n\$. Initial objects, via their morphisms, generate all the objects of the category. If there is an initial object, then it is unique in that if there is another initial object, it has the same diagrammatic topology -- all outgoing morphisms and no incoming morphisms save the identity. Thus, besides labels, two initials are isomorphic.

image::terminal.png[width=130,float=right]

A *terminal object* \$E\$ is the range of a set of morphisms \$S_n \rightarrow E\$. Terminal objects subsume all other objects in the category in that all other objects \$S_n\$ can be morphed into the terminal object, but the terminal object can not be morphed into any other object. Similar to initials, should another terminal exist, the two terminal are isomorphic in that they both have the same number of incoming morphisms and no outgoing morphisms (save the identity).

&nbsp;
****

A https://en.wikipedia.org/wiki/Cartesian_closed_category#Bicartesian_closed_categories[bicartesian closed category] has products, coproducts, a product unit, a coproduct unit, exponents, and products distribute over coproducts. These features are captured by the following axioms that all BC categories must support.

[cols="2,3,4"]
|===
| axiom | mmlang type | description

| \$a + b = b + a \$                           | `<a\|b> = <b\|a>`                    | commutative coproducts
| \$(a + b) + c = a + (b + c)\$                | `\<<a\|b>\|c> = <a\|<b\|c>>`         | associative coproducts
| \$a \ast (b + c) = (a \ast b) + (a \ast c)\$ | `<a;<b\|c>> = \<<a;b>\|<a;c>>`       | distributivity
| \$0 + a = a\$                                | `<_{0}\|a> = a`                      | coproduct unit
| \$0 \ast a = 0\$                             | `<_{0};a> = _{0}`                    | coproduct unit annihilation
| \$1 \ast a = a\$                             | `<_{1};a> = a`                       | product unit
| \$c^ {b^a} = c^{a \ast b}\$                  | `<a;b;c> = <<a;b>;c>`                | currying
|===

==== The Inst Monoid

.Monoids
****
A https://en.wikipedia.org/wiki/Monoid[monoid] is a structure of the form \$\langle A,\ast \rangle\$, where \$A\$ is the carrier set closed under the associative binary operator \$\ast: A \times A \rightarrow A\$ with \$1 \in A\$ being the https://en.wikipedia.org/wiki/Identity_element[identity] such that for every \$a,b,c \in A\$, \$(a \ast b) \ast c = a \ast (b \ast c)\$ and \$a \ast 1 = 1 \ast a = a\$.
****

mm-ADT types serve numerous roles which are typically realized by many different sorts of objects in traditional programmable systems. The reason for this singular use is quite literally because the mm-ADT type system (and value system) is inductively generated from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] which is the https://en.wikipedia.org/wiki/Generator_(mathematics)[generator set] of the _syntactic_ **inst monoid** \[
\langle\texttt{inst},\ast\rangle, \]
where \$\tt{i\nst}\$ is the infinite set of all instruction compositions, \$\ast: \tt{i\nst} \times \tt{i\nst} \rightarrow \tt{i\nst}\$ an associative binary composition operator, and \$\tt{[no\op]} \in \tt{i\nst}\$ is the unique identity element. This "instruction-only" interpretation of mm-ADT realizes the general unitary form of mm-ADT \$ f: S \rightarrow E \$ where `S` is `obj{0}` (i.e. nothing). The `x\<=[start,x]` instruction is an *initial instruction* in that it returns it's arguments regardless of the input `obj` (or lack thereof).

\[
\texttt{[start,x]}: \texttt{obj\{0\}} \rightarrow \texttt{x}
\]

An mm-ADT program is a _type_, not a composition of instructions (\$ \tt{type} = (\tt{type} \times \tt{i\nst})\$). The way in which a dtype can be ground to a ctype using instructions only is via the `[start]` instruction. A single pass through the mm-ADT compiler yields a type trace based at a ctype.

image::start-ctypes.png[float="right",width=315]

[source]
----
mmlang> [start,int]
==>int
mmlang> [start,int][plus,5]
==>int[plus,5]
mmlang> [start,int][plus,5][gt,10]
==>bool<=int[plus,5][gt,10]
mmlang>
----

The `[noop]` instruction is the only mm-ADT instruction that does not alter the state of the `obj` trace graph and thus, the state of the computation. The instruction `[id]`, on the other hand, does.

[source]
----
mmlang> [start,int][plus,5][gt,10][noop]
==>bool<=int[plus,5][gt,10]
mmlang> [start,int][plus,5][gt,10][id]
==>bool<=int[plus,5][gt,10][id]
----

There exists an isomorphism (a https://en.wikipedia.org/wiki/Full_and_faithful_functors[bijective functor]) that maps the `inst` syntactic monoid to the type trace graph. This bijection proves that the syntax of `mmlang` is sufficient to express every possible mm-ADT type and vice versa, every mm-ADT type has a corresponding expression in `mmlang`.

image::inst-type-functor.png[width=35%,align=center]

The `inst`-monoid is an algebraic structure that can be used by all untyped languages wishing to compile to the mm-ADT VM. It can be used to write expressions, though, given the lack of typing, not all expressions will properly compile. The benefit of the `inst`-monoid is the simplicity of development, with the drawback of offloading the language-level type checking to the user.

==== The Type Ringoid

.Stream Ring Theory
****
https://zenodo.org/record/2565243[Stream ring theory] is a ring algebra defined by the https://en.wikipedia.org/wiki/Product_ring[direct product] of a *function* and *coefficient* ring, where every function/coefficient pair is an element of the carrier of a polynomial *stream* ring. The algebra is useful in asynchronous distributed computing environments that primarily enjoy https://en.wikipedia.org/wiki/Embarrassingly_parallel[embarrassingly parallel] processing, but where, at certain space and time https://en.wikipedia.org/wiki/Bulk_synchronous_parallel[synchronization] points, large amounts of data need to be co-located for processing. A proto-version of the stream ring algebra was realized in the distributed graph computing framework http://tinkerpop.apache.org[Apache TinkerPop].

mm-ADT adopts the algebra of stream ring theory, where functions are *instructions* and coefficients are *quantifiers*. mm-ADT's type system is realized as a https://en.wikipedia.org/wiki/Many-sorted_logic[multi-sorted] extension of the algebra.
****

mm-ADT's type system is founded on a multi-sorted https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] with https://en.wikipedia.org/wiki/Unit_(ring_theory)[unity] called the mm-ADT *type ringoid*. An algebraic ring is composed of a multiplicative monoid \$\langle A,\ast,1 \rangle\$ and a commutative additive group \$\langle A,\+,0\rangle\$ that share the same carrier set \$A\$. A https://ncatlab.org/nlab/show/Ab-enriched+category[ringoid] generalizes the mathematics of a ring to support the ring axioms on multi-sorted carriers \$A,B,C\$, etc. (i.e. typed structures). The mm-ADT type ringoid https://en.wikipedia.org/wiki/Generator_(mathematics)[generator] is the set of all ctypes and single instruction dypes covering `inst`, where, with the ringoid's multiplicative operator (`*`) and commutative additive operator (`+`), when faithfully applied according to sort, induce the set of all possible mm-ADT types.

* The *additive operator* `+` is structurally encoded using a `,-poly`, where each slot of the polynomial is an independent parallel type.
* The *multiplicative operator* `*` is structurally encoded using a `;-poly`, where each slot of the polynomial is a dependent serial type.
* The *additive identity* `0` is the polymorphic anonymous ctype `_{0}`.
* The *multiplicative identity* `1` is the polymorphic anonymous ctype `\_{1}`, which in `mmlang` is simply denoted `_`.

NOTE: The algebra underlying most type theories operate as a https://en.wikipedia.org/wiki/Semiring[semiring(oid)], where the additive component is a https://en.wikipedia.org/wiki/Monoid[monoid] as opposed to an invertible https://en.wikipedia.org/wiki/Group_(mathematics)[group]. In mm-ADT, the elements of the additive component can be inverted by their corresponding _negative type_ (or negative `obj` in general). Thus, mm-ADT realizes an additive https://en.wikipedia.org/wiki/Groupoid[groupoid], where, for example, the `,-poly` `[int{1},int{-1}]` merges to `int{0}` and thus, the initial `obj` as

\[
\begin{split}
\texttt{[int\{1\},int\{-1\}]>-} & \implies \\
\texttt{int\{1-1\}}             & \implies \\
\texttt{int\{0\}}               & \implies \\
\texttt{_{0}}                   & .
\end{split}
\]


[source]
----
mmlang> [int{1},int{-1}]
==>[int,int{-1}]
mmlang> [int{1},int{-1}]>-
mmlang>
----

Every ring(oid) must satisfy the following axioms. The respective `mmlang` expressions are provided where `a`,`b`, and `c` are respectfully sorted mm-ADT types.

.Ring with Unity Axioms
[cols="^4,^4,^5"]
|===
| common notation                    | terminology                              | mmlang notation

|\$(a + b) + c = a + (b + c)\$       | additive associativity                   | `\<<a,b>,c>` \$\cong\$ `<a,<b,c>>`
|\$0 + a = a + 0 = a\$               | additive identity                        | `<\_{0},a>` \$\cong\$ `<a,_{0}>` \$\cong\$ `a`
|\$a - a = a + (-a) = 0\$            | additive inverses                        | `<a,a{-1}>` \$\cong\$ `_{0}`
|\$a + b = b + a\$                   | additive commutativity                   | `<a,b>` \$\cong\$ `<b,a>`
|\$(a * b) * c = a * (b * c)\$       | multiplicative associativity             | `\<<a;b>;c>` \$\cong\$ `<a;<b;c>>`
|\$1 * a = a * 1 = a\$               | multiplicative identity                  | `<\_;a>` \$\cong\$ `<a;_>` \$\cong\$ `a`
|\$(a + b) * c = (a * c) + (b * c)\$ | multiplicative left distributivity       | `\<<a,b>;c>` \$\cong\$ `<<a;c>,<b;c>>`
|\$a * (b + c) = (a * b) + (a * c)\$ | multiplicative right distributivity      | `<a;<b,c>>` \$\cong\$ `\<<a;b>,<a;c>>`
|===

The most commonly used theorems entailed by the ring axioms are provided below.

.Ring with Unity Theorems
[cols="^4,^2,^4"]
|===
| common notation                    | deduction                                | mmlang notation

|\$a + b = a + c \=> b = c\$         | factors                                  |
|\$a + b = 0 \=> a = -b & b = -a\$   | unique inverse                           |
|\$-(a+b) = (-a) + (-b)\$            | distributivity                           | `<a,b>{-1}` \$\cong\$ `<a{-1},b{-1}>`
|\$-(-a) = a\$                       | distributivity                           | `<a{-1}>{-1}` \$\cong\$ `a`
|\$a*0 = 0 = 0*a\$                   | annihilator                              | `<a;_{0}>` \$\cong\$ `\_{0}` \$\cong\$ `<_{0};a>`
|\$a * (-b) = -a * b = -(a * b)\$    | factors                                  | `<a;b{-1}>` \$\cong\$ `<a{-1};b>` \$\cong\$ `<a;b>{-1}`
|\$(-a) * (-b) = a * b\$             | factors                                  | `<a{-1};b{-1}>` \$\cong\$ `<a;b>`
|===

Every corresponding `mmlang` expression makes use of `poly`-types. In `mmlang`, a `poly` can be denoted as a _structure_ via `[ ]` (a value) or as a _process_ via `< >` (a type). The example 3-slot `int` `,-poly` below has a domain of `int` and a range of `int{1,3}`. This branch structure will product one, two, or three `ints` given a single `int`.

[source]
----
mmlang> int<int[is>0],int[is<0],int>
==>int{1,3}<=int-<[
     int{?}<=int[is,bool<=int[gt,0]],
     int{?}<=int[is,bool<=int[lt,0]],
     int
   ]>-
----

The `< >` `poly` form is `mmlang` sugar with the following derivation.

\[
\begin{split}
\texttt{<a,b,c>}               & \implies \\
\texttt{-<[a,b,c]>-}           & \implies \\
\texttt{[delta,a,b,c][nabla]}  & \implies \\
\end{split}
\]

[source]
----
mmlang> 5<int[is>0],int[is<0],int>
==>5{2}
mmlang> 5-<[int[is>0],int[is<0],int]>-
==>5{2}
mmlang> 5[split,int[is>0],int[is<0],int][merge]
==>5{2}
----



===== Axioms, Diagrams, and Notation

The ring https://en.wikipedia.org/wiki/Axiom[axioms] are presented below along with the respective mm-ADT structure denoted in the `mmlang` `< >`-sugar form.

The table on the right provides the (most well-known) logical entailments of said axioms -- i.e., https://en.wikipedia.org/wiki/Theorem[theorems]. Example mm-ADT types demonstrating the equalities of the ring axioms are presented below in `mmlang`, where

* \$a\$ is `int[plus,1]` with sugar of `+1`
* \$b\$ is `int[mult,2]` with sugar of `*2`
* \$c\$ is `int[mult,3]` with sugar of `*3`

Though any combinations of respectively sorted instructions can be used.

.The Ring Axioms in mmlang
[cols="^3,4,3"]
|===
|Ring Axiom |mm-ADT Diagram |mmlang Denotation

|\$(a + b) + c = a + (b + c)\$
|image:additive-associativity.png[link=images/language/additive-associativity.png]
a|
[.small]
[source]
----
mmlang> 1<<+1,*2>,*3>
==>2{2}
==>3
mmlang> 1<+1,<*2,*3>>
==>2{2}
==>3
----

|\$0 + a = a + 0 = a\$
|image:additive-identity.png[link=images/language/additive-identity.png]
a|
[.small]
[source]
----
mmlang> 1<[id]{0},+1>
==>2
mmlang> 1<+1,[id]{0}>
==>2
----


|\$a - a = a + (-a) = 0\$
|image:additive-inverse.png[link=images/language/additive-inverse.png]
a|
[.small]
[source]
----
mmlang> 1<<+1,*2>,*3>
==>2{2}
==>3
mmlang> 1<+1,<*2,*3>>
==>2{2}
==>3
----

|\$a + b = b + a\$
|image:additive-commutativity.png[link=images/language/additive-commutativity.png]
a|
[.small]
[source]
----
mmlang> 1<+1,*2>
==>2{2}
mmlang> 1<*2,+1>
==>2{2}
----

|\$(a * b) * c = a * (b * c)\$
|image:multiplicative-associativity.png[link=images/language/multiplicative-associativity.png]
a|
[.small]
[source]
----
mmlang> 1<<+1;*2>;*3>
==>12
mmlang> 1<+1;<*2;*3>>
==>12
----

|\$1 * a = a * 1 = a\$
|image:multiplicative-identity.png[link=images/language/multiplicative-identity.png]
a|
[.small]
[source]
----
mmlang> 1<[id];+1>
==>2
mmlang> 1<+1;[id]>
==>2
mmlang> 1+1
==>2
----

|\$(a + b) * c = (a * c) + (b * c)\$
|image:multiplicative-right-distributivity.png[link=images/language/multiplicative-right-distributivity.png]
a|
[.small]
[source]
----
mmlang> 1<<+1,*2>;*3>
==>6{2}
mmlang> 1<<+1;*3>,<*2;*3>>
==>6{2}
----

|\$a * (b + c) = (a * b) + (a * c)\$
|image:multiplicative-left-distributivity.png[link=images/language/multiplicative-left-distributivity.png]
a|
[.small]
[source]
----
mmlang> 1<+1;<*2,*3>>
==>4
==>6
mmlang> 1<<+1;*2>,<+1;*3>>
==>4
==>6
----
|===




[width=45%,float=center]
|===
a|
[.small]
[source]
----
mmlang> 1<[plus,1],[mult,2]>{-1}
==>2{-2}
mmlang> 1<[plus,1]{-1},[mult,2]{-1}>
==>2{-2}
mmlang> 1<[plus,1]{-1}>{-1}
==>2
mmlang> 1[plus,1]
==>2
mmlang> 1<[plus,1];[id]{0}>
mmlang> 1[id]{0}
mmlang> 1<[id]{0};[plus,1]>
mmlang> 1<[plus,1];[mult,2]{-1}>
==>4{-1}
mmlang> 1<[plus,1]{-1};[mult,2]>
==>4{-1}
mmlang> 1<[plus,1];[mult,2]>{-1}
==>4{-1}
mmlang> 1<[plus,1]{-1};[mult,2]{-1}>
==>4
mmlang> 1<[plus,1];[mult,2]>
==>4
----
|===
'''
