:imagesdir: ./images/language
== Language Structures

.Products and Coproducts
****
https://en.wikipedia.org/wiki/Category_theory[Category theory] is the study of structure via manipulations that expose (or generate) other structures. Two important category theoretic concepts used throughout this section are *products* and *coproducts*.

image::product.png[float="left",width=225]

A https://en.wikipedia.org/wiki/Product_(category_theory)[product] is any object defined in terms of it's accessible component objects. That is, from a single object, via \$\pi_n\$ projection morphisms, the product is decomposed into it's constituent parts.

image::coproduct.png[float="right",width=225]

A https://en.wikipedia.org/wiki/Coproduct[coproduct] is any object defined in terms the component objects used to construct it. That is, from many objects, via \$\iota_n\$ injection morphisms, a coproduct can be composed from constituent parts.

Along with these decomposition (and composition) morphisms, there exists an https://en.wikipedia.org/wiki/Isomorphism[isomorphism] between any two products (or coproducts) should they project (or inject) to the same component objects. That is, product and coproduct equality are defined via component equality.
****

image::obj-type-value-q.png[float="left",width=300]

The mm-ADT VM operates on quantified objects known as `objs`. Every object is either a *type* or a *value*.

\[
\begin{split}
\tt{obj} &=\;& \tt{object} * \tt{q} \\
\tt{object} &=\;& \tt{type} + \tt{value}
\end{split}
\]

A type denotes a _stream_ (i.e. https://en.wikipedia.org/wiki/Multiset[multi-set] or bag) of `obj` values. Values denote atomic or composite datum existing outside the mm-ADT VM within it's execution environment. For instance, if an mm-ADT VM is implemented on the https://en.wikipedia.org/wiki/Java_virtual_machine[JVM], then the `str` value `'mmadt'` refers to the `java.lang.String` instance `"mmadt"`. Both `obj` types and values have associated *quantifiers* (`q`). The meaning of quantification is dependent on the quantifier type used with an mm-ADT program (e.g. integers, reals, unitary matrices, etc.). However, in general, the intuition is that the quantifier denotes the _amount_ of values being referred to.

The axioms of https://en.wikipedia.org/wiki/Ring_theory[algebraic ring theory] specify that rules of type composition and thus, how programs are written, streams are constructed, functions are defined, and of particular import to mm-ADT, how functorial mappings between different https://en.wikipedia.org/wiki/Abstract_data_type[abstract data types] are specified.

=== Types

image::obj-monoid.png[float="right",width=70]

mm-ADT types serve numerous roles which are typically realized by many different sorts of objects in traditional programmable systems. The reason for this singular use is quite literally because the mm-ADT type system is inductively generated from the https://en.wikipedia.org/wiki/Monoid[monoid] `obj{*}`, where it's elements (i.e. types) ultimately refer to streams of values. mm-ADT program evaluation can be understood as https://en.wikipedia.org/wiki/Dereference_operator[dereferencing] the type denoting the program to yield (itemize) it's referent values -- i.e. program results.

image::type.png[float="left",width=360]

There are two kinds of mm-ADT types: *canonical types* (ctypes) and *derived types* (dtypes). There are 6 ctypes which comprise the fundamental base types of the mm-ADT VM: `bool`, `int`, `real`, `str`, `lst`, or `rec`. A dtype is the product of a type and an instruction (`inst`), where the type component serves as the _domain_, the instruction component the _function_, and the type product as a whole, relative to it's components, the _range_.

\[
\begin{split}
\tt{type} &=\;& (\tt{dtype} &\;*\;& \tt{inst}) &\;+\;& \tt{ctype} \\
\text{â€œrange} &=\;& (\text{domain} &\;\text{and}\;& \text{function}) &\;\text{or}\;& \text{constant"}
\end{split}
\]

The dtype's recursive definition is grounded at the 6 ctypes, where every canonical type is it's own domain and range. The dtypes are generated https://en.wikipedia.org/wiki/Recursive_data_type[inductively] by applying instructions from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (`inst`). When applied to types, every `inst` yields a distinct dtype that is a structural expansion of the previous type.

image::types.png[align=center,width=40%]

image::obj-full.png[float=right,width=420]

The example below demonstrates how instructions applied to types create new types. The diagram on the right presents the products and co-products that form the general structure of the mm-ADT VM language (which is realized in mmlang).



[source]
----
mmlang> int
==>int
mmlang> int[plus,4]
==>int[plus,4]
mmlang> int[plus,4][mult,42]
==>int[plus,4][mult,42]
mmlang> int[plus,4][mult,42][gt,42]
==>bool<=int[plus,4][mult,42][gt,42]
----





==== Type Signatures

[source]
----
mmlang> int[plus,4][mult,42][gt,42]
==>bool<=int[plus,4][mult,42][gt,42]
----

The expression above highlights two important components of a type: _signature_ and _definition_. These two concepts are presented below in pseudo-`mmlang` notation.

[source]
----
range{q}<=domain{q}([inst]{q})*
|_________________||__________|
     signature      definition
----

Every mm-ADT type can be generally understood as a function that maps an `obj` of one type to an `obj` of another (potentially
equivalent) type. A *type signature* specifies the source and target of this mapping, where the "domain" is the source type and the "range" is the target type. Both the domain and range type specifications include a respective quantification denoted `{q}`.

[source]
----
range{q}<=domain{q}
----

Type's that are fully specified by their type signature are always canonical types. The examples below demonstrates various `ctype` expressions in order to highlighting various `mmlang` syntax sugars.

[source]
----
mmlang> int{1}                      <1>
==>int
mmlang> int<=int                    <2>
==>int
mmlang> int<=bool                   <3>
language error: bool is not of int
mmlang> int{5}                      <4>
==>int{5}
mmlang> int{0,5}                    <5>
==>int{0,5}
mmlang> int{0,5}<=int{0,5}          <6>
==>int{0,5}
----
<1> In most programming languages, a value can be typed `int` as in `val x:int = 10`. Such https://en.wikipedia.org/wiki/Declaration_(computer_programming)[declarations] state that the value referred to by `x` is a _single_ element within the set of integers. The concept of a "single element" is captured in mm-ADT via quantification. When the quantifier is the https://en.wikipedia.org/wiki/Unit_(ring_theory)[unit] of the underlying quantifier ring, then the quantifier is not displayed in `mmlang`.
<2> From the perspective of a function, An mm-ADT `int` is a https://en.wikipedia.org/wiki/NOP_(code)[no-op] on the set of integers. Given any integer, `int` returns that integer. In `mmlang`, when the domain and range are the same, the `<=` and repeated type are not displayed.
<3> Without any instructions, there is no way for a type to legally map a `bool` to an `int`.
<4> An mm-ADT type always refers to an unordered https://en.wikipedia.org/wiki/Multiset[multi-set] (or bag) of elements known as a _stream_. `int{5}` is a type referring to 5 integers (with repeats possible). As a point of comparison, `int` denotes a stream containing a single integer. This is why `int` is syntactic sugar for `int{1}` in `mmlang`.
<5> The quantifier ring can be any ring with unity. In the previous examples, the chosen ring's https://en.wikipedia.org/wiki/Algebraic_structure[carrier set] was the set of integers. In this example, the carrier set is two integers and is used to capture uncertainty as to the number of elements being referred to. `int{0,5}` is a type referring to either 0, 1, 2, 3, 4, or 5 integers.
<6> This further emphasizes the fact that every mm-ADT type (even canonical types) are functions with a quantified domain and a quantified range.

==== Type Definitions

mm-ADT type signatures specify the canonical type and quantity of the type's domain and range. Further specification of the nature of the elements of the type is accomplished via a *type definition*. The following mm-ADT type is known as a https://en.wikipedia.org/wiki/Refinement_type[refinement type] because it provides further
constraint/refinement on which particular integers in `int` the type is refering to. This particular type is the mm-ADT definition of a natural number in \$\mathbb{N}\$.
\[
\tt{int[is,[gte,0]]} \equiv \mathbb{N}
\]
An itemization of the structural components of the written form of this type in `mmlang` is presented below, where `r/d` refers to range/domain, `op` the instruction opcode, `arg` the instruction argument, and `inst` the instruction as a whole, where in this particular example, the argument to the instruction is a type (whose structure is inferred from the provided instruction).
[source]
----
int[is,[gte,0]]
|_|||_||_____||
r/d|op | arg ||
   |   |_____||
   |     type |
   |__________|
       inst
----

The structure `[is,[gte,0]]` is an *instruction* with a single argument. mm-ADT instruction opcodes denote specific operations explicitly implemented by the mm-ADT virtual machine. The set of all mm-ADT instructions forms the machine's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture].

A type is transformed into another type via an instruction application. Every instruction is able to operate on both types and values. In this way, instruction application on types yields program _compilation_ and instruction application on values yields _evaluation_. The compilation of a type produces a type, where quantification and domain/range specifications are inferred when unspecified by the user.

[source]
----
mmlang> int[is,[gte,0]]                      <1>
==>int{?}<=int[is,bool<=int[gte,0]]          <2>
mmlang> int int[is,[gte,0]]                  <3>
==>int{?}<=int[as,int][is,bool<=int[gte,0]]
mmlang> 6 int{?}<=int[is,bool<=int[gte,0]]
==>6                                         <4>
mmlang> -6 int{?}<=int[is,bool<=int[gte,0]]  <5>
mmlang>
----
<1> A base type composed with an instruction/quantifier pair, where the quantifier is not displayed as it's the unit
of the quantifier ring -- `{1}`.
<2> A compiled type that maps a single integer to zero or one integers. If the internal `bool\<=int[gte,0]` type yields
`true`, then an `int{1}`, else `int{0}`.
<3> A type operates on an `int` thus, if supplied "an `int` type", the type operates on it to yield a type. The use of types to process types is a form of compilation generally known as https://en.wikipedia.org/wiki/Abstract_interpretation[abstract interpretation].
<4> The type maps the positive integer `6{1}` to `6{1}` (_some_).
<5> The type maps the negative integer `-6{1}` to `-6{0}` (_none_).

NOTE: Any `obj` with the the quantifier ring's additive identity (`zero`) is not displayed by `mmlang` and can be safely garbage collected by the mm-ADT VM processor at anytime throughout a non-reducing computation without altering the semantics of the computation.

==== Type Structures

mm-ADT types can be understood from the perspective of various mathematical structures. The following subsection will discuss:

. *Type monoid*: types as elements of the `obj{*}` monoid.
. *Type graph*: types as directed, acyclic, binary multi-graphs.
. *Type ring*: types as elements of a ring with unity where `*` is serial compose and `+` is parallel compose.
. *Type category*: types as objects in a category with instruction morphisms and the role of equational reasoning.

===== Type Monoid

****
.Definition: Monoid
A https://en.wikipedia.org/wiki/Monoid[monoid] is a structure of the form \$\langleA,\ast\rangle\$, where \$A\$ is the carrier set closed under the associative binary operator \$\ast: A \times A \rightarrow A\$ with \$1 \in A\$ being the identity such that for every \$a,b,c \in A\$, \$(a \ast b) \ast c = a \ast (b \ast c)\$ and \$a \ast 1 = 1 \ast a = a\$.
****

====== Model: mmmonoid

The `mmmonoid` model-ADT models the mm-ADT VM as a monoid whose carrier set elements are all the inductively derived types of `obj{*}` and where any two types can be composed using `[mult]`.

* \$A\$: types (\$\tt{ctype} \cup \tt{dtypes}\$)
* \$\ast\:A \times A \rightarrow A \$: `[mult]`-type composition
* \$1 \in A\$: `[noop]` identity element

[source]
----
mmlang> int{2}[plus,4][mult,bool<=int[gt,10]]
==>bool{2}<=int{2}[plus,4][gt,10]
mmlang> int{2}[plus,4] * bool<=int[gt,10]
==>bool{2}<=int{2}[plus,4][gt,10]
mmlang> int{2} * int[plus,4] * bool<=int[gt,10]
==>bool{2}<=int{2}[plus,4][gt,10]
----

===== Type Graph

The diagram below is a *type graph*. In graph theoretic notation,
\[
T = (V,E \subseteq (V \times \texttt{[inst]} \times V))
\]
is a directed binary edge-labeled https://en.wikipedia.org/wiki/Multigraph[multi-graph] where \$V\$ is the set of types (`ctypes` and `dtypes`) and \$E\$ is the set of instruction labeled edges between types. The particular type graph below represents the data structure generated by the `mmlang` expression
\[
\tt{int[plus,4][mult,2][gt,42]}.
\]

image:type-data-structure.png[align=center,width=100%]

It is important to note that the type graphs of each subexpression:
\[
\tt{int} \\
\tt{int[plus,4]} \\
\tt{int[plus,4][mult,2]}
\]
remain as subgraphs of the final expression's graph and that _this is the underlying data structure of the type within the mm-ADT VM_.

IMPORTANT: Every mm-ADT program is a type graph. The set of all possible type graphs and thus, all possible programs, can be generated via the aforementioned `[inst]` induction rooted at `obj{*}`. The resultant type graph family is the union of all possible programs and is known as `mm` (the "mm" in mm-ADT).

===== Type Ring

mm-ADT's type theory has a rich axiomatic semantics founded on https://en.wikipedia.org/wiki/Ring_theory[algebraic ring theory] and in particular, on https://zenodo.org/record/2565243[stream ring theory].

NOTE: In stream ring theory, instructions are called _functions_ and quantifiers are called _coefficients_. A function-coefficient pair is called a _stream_. The equivalence highlights the fact that mm-ADT types refer to streams of objects (i.e. https://en.wikipedia.org/wiki/Multiset[multi-sets] or bags).

In ring theory, if \$<A,+,\ast>\$ is a ring with \$A\$ the carrier set, \$0 \in A\$ the additive identity, \$1 \in A\$ the multiplicative identity, and \$a,b,c \in A\$, then the ring must obey the axioms itemized on the left. Every ring benefits from the theorems itemized on the right which are (the most popularly used) logical entailments of the axioms.

.Ring with Unity Axioms
[width=50%,float=left]
|===
|`(a + b) + c = a + (b + c)`
|`0 + a = a + 0 = a`
|`a - a = a + (-a) = 0`
|`a + b = b + a`
|`(a * b) * c = a * (b * c)`
|`1 * a = a * 1 = a`
|`(a + b) * c = (a * c) + (b * c)`
|`a * (b + c) = (a * b) + (a * c)`
|===

.Ring Axiom Entailments
[width=50%,float=right]
|===
|`a + b = a + c => b = c`
|`a + b = 0 => a = -b & b = -a`
|`-(a+b) = (-a) + (-b)`
|`-(-a) = a`
|`a*0 = 0 = 0*a`
|`a * (-b) = -a * b = -(a * b)`
|`(-a) * (-b) = a * b`
|===

&nbsp;

The type system of mm-ADT is characterized by a particular formulation of the https://en.wikipedia.org/wiki/Product_ring[direct product of rings] over the _quantifier_ and _instruction_ rings (discussed next). The product of these two rings is a ring itself called the _stream ring_. Thus, mm-ADT's types are founded on ring theory in general and stream ring theory in particular.

image::ring-structures.png[align="center",width=80%]

NOTE: Instructions and quantifiers are the carrier sets of two independent https://en.wikipedia.org/wiki/Ring_(mathematics)[rings] with unity whose https://en.wikipedia.org/wiki/Direct_product[direct product] forms the mm-ADT type ring and is the subject of study in https://zenodo.org/record/2565243[stream ring theory] (SRT). The type graph structure presented previously is a subgraph of a (pseudo) https://en.wikipedia.org/wiki/Cayley_graph[Cayley graph] formed from the multiplicative https://en.wikipedia.org/wiki/Group_(mathematics)[monoid] (w/ no multiplicative inverse) component of that ring.

====== The Instruction Ring

In mm-ADT, the carrier set of the *instruction ring* is the set of all instructions, where

* `inst` is the carrier set,
* `*` is serial composition,
* `+` is parallel composition,
* `0` is `[none]` and
* `1` is `[all]`.

In the table below `[a]`, `[b]`, and `[c]` are variable instructions in `inst`, where `[none] == [is,false]` and `[all] == [is,true]`.

.The Ring Axioms in mmlang
[cols="2,4"]
|===
|Ring Axioms                        |Related mmlang Types

|`(a + b) + c = a + (b + c)`        |`[branch,[branch,[a],[b]],[c]] == [branch,[a],[branch,[b],[c]]]`
|`0 + a = a + 0 = a`                |`[branch,[none],[a]] == [branch,[a],[none]] == [a]`
|`a - a = a + (-a) = 0`             |`[branch,[a],[a]{-1}] == [none]`
|`a + b = b + a`                    |`[branch,[a],[b]] == [branch,[b],[a]]`
|`(a * b) * c = a * (b * c)`        |`[map,[a][b]][c] == [a][map,[b][c]]`
|`1 * a = a * 1 = a`                |`[all][a] == [a][all] == [a]`
|`(a + b) * c = (a * c) + (b * c)`  |`[branch,[a],[b]][c] == [branch,[a][c],[b][c]]`
|`a * (b + c) = (a * b) + (a * c)`  |`[a][branch,[b],[c]] == [branch,[a][b],[a][c]]`
|===

IMPORTANT: A known "bug" in stream ring theory is that not all instructions in `inst` have an additive inverse. Thus, it is not the case that every instruction set can serve as the carrier of a ring. Fortunately, in the larger composite type ring (discussed later), which forms the primary algebraic structure in mm-ADT's type system, the quantifier ring's multiplicative inverse can be used to remedy the situation--see the 3rd entry in the table above.

As an example, the instructions `[plus,10]` and `[gt,5]` can be combined via serial and/or parallel composition. In general, all serial and parallel compositions are https://en.wikipedia.org/wiki/Associative_property[associative] except for those that use instructions from a particular `inst` subring known as the _the reduce near-ring_ (discussed later).

[source]
----
mmlang> [plus,10] int[mult,[gt,5]]
==>[plus,10][gt,5]
mmlang> [plus,10] inst[plus,[gt,5]]
==>[branch,[plus,10],[gt,5]]
----

The https://en.wikipedia.org/wiki/Distributive_property[distributivity] of multiplications over addition is made apparent with expressions below which have a diagrammatic representation, where the edges/arrows are streams of `objs` that are being operated on by the `insts` vertex/objects they meet along the way. Whenever the diagram branches, the `obj` at the branch is cloned, taking _both_ branches.

\[
\texttt{x[branch,[a],[b]]} = \uplus <\texttt{x[a]},\texttt{x[b]}>
\]

[source]
----
[plus,10][branch,[gt,5],[lt,2]]  ==  [branch,[plus,10][gt,5],[plus,10][lt,2]]
----

// https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBpiBdUkANwEMAbAVxiRAB12cdhkAjAE50wAYwAWpAL4hJpdJlz5CKAEykADFVqMWbTt14BzHKQCsFabPnY8BImpVb6zVog5ceyBiceW5IDBslInVyJx1XdwNkNGY4ck0-a0U7FABmMOpnXTd9HgsZf0CU5WQAFkztFz12GABHJiwaQuTbUtNK7Mi83kFhcSkWgIU2ogA2DXDq3I9eWKZ44kSh4tGUCccsiJro+cXlq2Gg1OQAdkmt6ajPYzMCw9XglHPNqpzr3m9SXxWRp+QABydbYzAz3LQwKCGeBEUAAMwEEAAtkhQiAcBAkMRDgjkajqBikCocYiUYgMujMYh1CS8YgyJSkGVaWS1IzEMz-LiyRN2acWUheYTEACBYhzuyAJxioHspZipYEqnEbFc0lISVKrHYixAA
image::inst-left-distrib.png[width=750,align=center]

[source]
----
[branch,[plus,10],[mult,5]][gt,7]  ==  [branch,[plus,10][gt,7],[mult,5][gt,7]]
----
// https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBoBGAXVJADcBDAGwFcYkQAdDnHYZAIwBO9MAGMAFqQC+IKaXSZc+QinKli1Ok1bsuPPmhZwKGmXIXY8BImoBMmhizaJO3XsgC2zRjlIBWSjN5EAxLZSJbCgdtZ1d9QNlg0KVrFAAWKJpHHRcuGABHZixaRIsUlWQ-TK0nXTc+IREJaVKQxSsKgDZ1aNrc+uRDZmNyU1bkjqJu+yyYuv1Pb18AoLLJlAB2Htm+uPcAc18NhPM2sNTkLZmanL2+Q9Jj1bPyogAOauzYvV4TpPbwigAMyfOb9BYPJ6yTQwKD7eBEUAAM0EEA8SDIIBwECQ5FOKLRGJo2KQtnxqPRiDUWJxiCB5MJiEiNKQ9OCBMpVRZiE6DM5xNpGz5SG63LewsQW25AE4JdKBbjiBKPtzRhKQaq8YEgA
image::inst-right-distrib.png[width=750,align=center]

====== The Quantifier Ring

.Quantifier Symbols in mmlang
[width=35%,cols="1,1,2,float=right]
|===
|usage   |sugar  | unsugared

|https://en.wikipedia.org/wiki/Option_type[none]/nothing   |`{0}`  | `{0,0}`
|https://en.wikipedia.org/wiki/Option_type[some]/just      |       | `{1,1}`
|exact          |`{x}`  | `{x,x}`
|least footnote:order[Applicable to quantifier rings with an total order over the carrier.]         |`{x,}` | `{x,max}`
|most footnote:order[]          |`{,x}` | `{min,x}`
|https://en.wikipedia.org/wiki/Option_type[option]/maybe   |`{?}`  | `{0,1}`
|given footnote:order[]         |`{+}`  | `{1,max}`
|any footnote:order[]           |`{*}`  | `{1,max}`
|===


In the https://en.wikipedia.org/wiki/Type_theory#Difference_from_set_theory[set-theoretic interpretation of types], a type denotes a set in *Set*. A set does not contain repeated elements. A _stream_ generalizes a set. A stream is an unordered collection of `objs` of varying cardinality (a multi-set, or bag). For example, in mm-ADT, `int` is shorthand for `int{1}`--a single integer. This is analogous to other languages, where when `int` is used to define a value, it is referring to a single integer from the set of all integers--e.g., `val answer:int = 42`. Where mm-ADT differs from other languages is that `bool{42}` is a type denoting `42` boolean values.

All `mmlang` expressions within `{ }` operate on the mm-ADT VM's *_quantifier ring_* (w/ unity). Any object that supports `+`/`*`/`0`/`1` and the axioms governing their composition can be used as an mm-ADT quantifier. Along with Turing Complete types specifications, type definitions can be specified to as accurate or fuzzy a degree as computationally and conceptually possible.

Typically, the quantifier of choice for most applications is the `int` ring (or `int` range ring -- `{2,13}`). Common programming concepts that are usually captured by typeclasses or functors (via https://en.wikipedia.org/wiki/Lift_(mathematics)[lifting]) are expressed in mm-ADT via quantification.

[source]
----
int                                  // a single int   (some)
int{?}<=int[is,[gt,0]]               // 0 or 1 int     (option)
int{0}<=int[is,false]                // 0 ints         (none)
int{4}<=int{2}[branch,[id],[id]]     // 4 ints         (exact)
int{*}<=[=db][get,'costs']           // 0 or more ints (any)
----

===== Type Category

****
.Definition: Category
A https://en.wikipedia.org/wiki/Category_(mathematics)[category] is a structure \$C = (Obj,Hom)\$.
****

====== Model: mmcat

The mm-ADT `mmcat` model-ADT models the structure of mm-ADT using category theoretic structures of objects, morphisms, and functors.

An mm-ADT *Type* category is composed of `obj` _objects_ denoted `type` and a set of instruction _morphisms_ denoted `inst`. If two types objects are distinct by a single tail instruction, then there exists an `inst` morphism \$\tt{[a]}: X->Y\$ where the \$\mathcal{Dom}(\tt{[a]})\ * \tt{[a]} = \mathcal{Cod}(\tt{[a]})\$. The identity morphism of every `type` object is the `[id]` instruction. Every mm-ADT type category https://en.wikipedia.org/wiki/Commutative_diagram[commutes].

The https://en.wikipedia.org/wiki/Commutative_diagram[commutative diagram] of a simple type category is presented below where:

. _Objects_: `int`, `int[plus,2]`, `int[plus,2][plus,8]`, and `int[plus,2][plus,10]`
. _Morphisms_: `[plus,2]`, `[plus,8]`, `[plus,10]`, and respective identity instructions.


image::type-equiv.png[width=600,align="center"]

Every path through the diagram specifies a particular type construction

Thus, every mm-ADT program is an mm-ADT type. There exists an mm-ADT canonical type graph derived by from the previous type graph via a https://en.wikipedia.org/wiki/Forgetful_functor[forgetful functor], where the vertices denote the 6 base types and the edges denote https://en.wikipedia.org/wiki/Endomorphism[endomorphisms] of the base type monoid or https://en.wikipedia.org/wiki/Homomorphism[homomorphisms] between two type monoids.

image::type-equivalence.png[width=100%,align="center"]

==== Type Examples

mm-ADT types differ from convention in that they serve to denote:

* *Canonical types*: sets of elements denoted as `int` or `str`, etc.
* *Refined types*: constraints on the canonical set types such as `nat<=int[is,[gt,0]]`
* *Quantified types*: specifying the cardinality of a set via quantification `int{0,5}` (a type of 0 to 5 `int` values).
* *Dependent types*:
* *Translating types*: specify a mapping from a domain set of elements to a range set of elements as in `int[plus,2]`.
* *Recursive types*:

===== Canonical Types

The _unquantified_ canonical types are the most expressive types of many programing language type systems. For example, the type `int` in mm-ADT is quantified at unity `{1}` and thus, considered unquantified. There are 7 unquantified canonical types in mm-ADT. With _quantification_ these types no longer describe individual objects, but streams of objects.

[source]
----
mmlang> 1{3} int{3}
==>1{3}
mmlang> 1{3} int{2}
language error: 1{3} is not a int{2}
mmlang> 1{3} int{2,10}
==>1{3}
----

===== Refinement Types

In the theory of types as sets, a refinement type is a subset of a larger type set where the subset specification provides more information to the type inference to determine whether the objects created will be within the refined subset.

[source]
----
mmlang> int[is,[gt,0]]
==>int{?}<=int[is,bool<=int[gt,0]]
mmlang> int<=int[is,[gt,0]]
==>int[is,bool<=int[gt,0]]
----

===== Quantified Types

[source]
----
mmlang> int[is>0 -> +1 | is>10 -> +2]
==>int[choose,[int{?}<=int[is,bool<=int[gt,0]]:int[plus,1]
              |int{?}<=int[is,bool<=int[gt,10]]:int[plus,2]]]
mmlang> int[is>0 -> +1 & is>10 -> +2]
==>int{0,2}<=int[branch,[int{?}<=int[is,bool<=int[gt,0]]:int[plus,1]
                                    &int{?}<=int[is,bool<=int[gt,10]]:int[plus,2]]]
----

===== Dependent Types

===== Translation Types

A translation type maps objects of one type to objects of another type that is neither a sub- or superset of the original type. While having the apperance of a general function, translation types provide a way to reason about the equivalence of two seemingly different mappings.

[source]
----
mmlang> int[is,[gt,10][and[lt,100]]][as,str][len]
==>int{?}<=int[is,bool<=int[gt,10][and,bool[lt,100]]][as,str][len]
mmlang> int{?}<=int[is,[gt,40][and[lt,50]]][as,str][len]
==>int{?}<=int[is,bool<=int[gt,40][and,bool[lt,50]]][as,str][len]
----


===== Recursive Types



////
=== Model Categories and their Functors

An mm-ADT _model_ specifies relationships between a set of types within a https://en.wikipedia.org/wiki/Domain_of_discourse[_domain of discourse_].
These relationships are https://en.wikipedia.org/wiki/Path_(topology)[path equations] that specify semantic equivalences between types.
There are two general classes of models:

. *Category*: A category model has `ctype` and `type` mappings to other `ctypes` and `types` within the category.
. *Functor*: A functor model maps `ctypes` and `types` from one category model to a `ctypes` and `types` in another category model.

Every mm-ADT model excluding instructions from the reduce near-ring, forms a https://en.wikipedia.org/wiki/Category_(mathematics)[category], where
the category's _objects_ are the canonical types (`ctypes`) and the _arrows_ are types that span the canonicals.
mm-ADT models are defined via types that are constructed via the instruction ring where both `+` and `*` are associative
and the `[id]` instruction serves as the identity as in `int<=int[id]`.

A _model_ is a `rec` that specifies how a "left-hand side" (LHS) type maps to a "right-hand side" (RHS) type.
Both object and arrow morphisms are captured in this structure.
The model below is a _functor model_ in that is specifies how to move from the category of `int` to the category of `nat`.

[source]
----
rec[
  int<=int[is,[gte,0]] -> nat,
  int[plus,[id]]       -> nat[mult,2]]
----

The above model is diagrammed below where object morphisms are solid lines and the arrow morphism is the dotted line.

[ditaa,"int-nat-functor",align="center"]
....
         int---[plus,[id]]--->int

           |         |          |
           |         |          |
int[is[gte,0]]       :         int[is[gte,0]]
           |         |          |
           v         v          v

         nat-----[mult,2]---->nat
....

[source]
----
mmlang> :model clear
mmlang> :model rec[int<=int[is>=0] -> nat]
mmlang> :model rec[int + [id] -> nat * 2]
mmlang> :model
int ->
	int[is,bool<=int[gte,0]] -> nat
	int[plus,int[id]] -> nat<=int[is,bool<=int[gte,0]][mult,2]
mmlang> 32
==>nat:32
mmlang> 32[plus,[id]]
==>nat:64
mmlang> int[plus,[id]][explain]
==>str<=[start,'
nat<=int[is,bool<=int[gte,0]][mult,2]
instruction             domain      range    state
---------------------------------------------------
[is,bool<=int[gte,0]]    int    =>   int{?}
 [gt,0]                  int   =>    bool
[mult,2]                nat    =>   nat
']
mmlang>
----
////
////
A complex type definition is provided below that captures a large number of the mm-ADT type constructs.

[source]
----
int<=int{2}<x>[plus,10]<y>[is.<10 -> <x>
                          |is.<20 -> <y>
                          |int    -> <x>+<y>][count]
----

.mmlang Language Structures
[cols="75,1,200"]
|===
|Classification          |`mmlang` |Description

|`obj` instruction       |`[ ]`    |The bulk of instructions operate on `objs`.
|traverser instruction   |`< >`    |Traversers are independent computational contexts that can be programmed.
|quantifiers             |`{ }`    |Every `obj` has a quantity as specified by the associated algebraic ring w/ unity.
|branching instructions  |`[->]`   |A `rec` type is used for guarded branching.
|domain/range specifies  |`<=`     |Every type has a domain and a range. Classic types have are endomorphisms.
|===
////
