:imagesdir: ./images/language
:subs: non

== Language Structures

image::compiling-languages.png[float="right",width=300]

The mm-ADT VM is written in https://scala-lang.org/[Scala].
It contains a fluent program builder https://en.wikipedia.org/wiki/Application_programming_interface[API] called `mmscala`. Most compiler designers should avoid `mmscala` as direct access to the https://en.wikipedia.org/wiki/Java_virtual_machine[JVM] and the full JDK can create unsafe mm-ADT programs. Instead, `mmlang` should be the target language for most compilers.
Moreover, all compilers targeting `mmlang` can be used across different mm-ADT VM implementations.

IMPORTANT: The recommended target language for all higher-level language compilers is `mmlang`.

.Products and Coproducts
****
https://en.wikipedia.org/wiki/Category_theory[Category theory] is the study of structure via manipulations that expose (or generate) other structures.
Two important category theoretic concepts used throughout this section are *products* and *coproducts*.

image::product.png[float="left",width=225]

A https://en.wikipedia.org/wiki/Product_(category_theory)[product] is any object defined in terms of it's accessible component objects.
That is, from a single object, via \$\pi_n\$ projection morphisms, the product is decomposed into it's constituent parts.

image::coproduct.png[float="right",width=225]

A https://en.wikipedia.org/wiki/Coproduct[coproduct] is any object defined in terms the component objects used to construct it.
That is, from many objects, via \$\iota_n\$ injection morphisms, a coproduct can be composed from constituent parts.

Along with these decomposition (and composition) morphisms, there exists an https://en.wikipedia.org/wiki/Isomorphism[isomorphism] between any two products (or coproducts) should they project (or inject) to the same component objects.
That is, product and coproduct equality are defined via component equality.
****

=== The Obj

image::obj-type-value-q.png[role=left,padding-left=303,width=280]

Everything that can be denoted in `mmlang` is an `obj`.
Within the VM and outside the referential purview of an interfacing language, every `obj` is the product of

. An *object* that is either a *type* or a *value* and
. A *quantifier* specifying the "amount" of objects being denoted.

\[
\texttt{obj} = (\texttt{type} + \texttt{value}) \times \texttt{q}.
\]

image::obj-type-q-value-q.png[float=right,width=450]

This internal structure is well-defined as an https://en.wikipedia.org/wiki/Ring_(mathematics)[algebraic ring]. The ring axioms specify how the internals of an `obj` are related via two binary operators: \$\times\$ and \$\+\$ . One particular axiom states that products both left and right https://en.wikipedia.org/wiki/Product_(category_theory)#Distributivity[distribute] over coproducts.
Thus, the previous formula can be rewritten as \[
\texttt{obj} = (\texttt{type} \times \texttt{q}) + (\texttt{value} \times \texttt{q}).
\]
This representation, which is https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to the previous, states two distinct kinds of mm-ADT `objs`: *quantified types* and *quantified values*.
This is the *obj meta-model*.

[source]
----
mmlang> int            <1>
==>int
mmlang> 1              <2>
==>1
mmlang> int{5}         <3>
==>int{5}
mmlang> 1{5}           <4>
==>1{5}
mmlang> 'a','b','a'    <5>
==>'a'{2}
==>'b'
----
<1> A single `int` type.
<2> A single `int` value of `1`.
<3> Five `int` types.
<4> Five `1` `int` values.
<5> A type containing `'a'`,`'b'`, and `'a'` `str` values.

==== Types and Values

Many modern programming environments make a sharp distinction between types and values, where each is predominately the focus of either https://en.wikipedia.org/wiki/Compiler[compilation] (types) or evaluation (values). In mm-ADT, every instruction operates on both types and values. Two interesting consequences are

. Compilation is the evaluation of a program with a type argument (\$ \tt{type} \rightarrow \tt{type} \rightarrow \tt{type} \$) and
. Types serve as https://en.wikipedia.org/wiki/Anonymous_function[lambda (or anonymous) functions] during evaluation (\$ \tt{value} \rightarrow \tt{type} \rightarrow \tt{value} \$).

[source]
----   
mmlang> int int[is,[gt,0]]                 <1>
==>int{?}<=int[is,bool<=int[gt,0]]
mmlang> 5 int{?}<=int[is,bool<=int[gt,0]]  <2>
==>5
----
<1> The `int`-type is applied to the `int[is,[gt,0]]`-type to yield an `int{?}`-type denoting either 0 or 1 `int` (*compilation*).
<2> The type `bool\<=int[gt,0]` serves as a lambda that yields `true` or `false` for every incoming `int` value (*evaluation*).

Some interesting conceptual blurs arise from the co-existence of types and values during compilation and evaluation. The particulars of the ideas in the table below will be discussed over the course of the documentation.

.Consequences of Type/Value Integration
[cols="2,2,13"]
|===
|structure A | structure B | unification

|type        | value      | quantifiers expand the cardinality of values and constrain the cardinality of types.
|type        | variable   | types refer to a values across contexts and variables refer to values within contexts.
|type        | AST        | a single https://en.wikipedia.org/wiki/Intermediate_representation[intermediate representation] is used in compilation, optimization, and evaluation.
|type        | function   | functions are (dependent) types with values generated at evaluation.
|type        | program    | a program is a "complicated" type.
|compilation | evaluation | compilations are type evaluations, where a compilation error is a "compilation runtime" error.
|state       | trace      | types and values both encode state information in their process traces.
|classical   | quantum    | quantum computing is classical computing with a unitary matrix quantifier ring.
|canonical   | atomics    | atomic values and canonical types are both "tokens" by which all constructions are built.
|===

=== The Type

An `obj` was previously defined as \[
\texttt{obj} = (\texttt{type} \times \texttt{q}) + (\texttt{value} \times \texttt{q}).
\]

That equation is not an https://en.wikipedia.org/wiki/Axiom[axiom], but a https://en.wikipedia.org/wiki/Theorem[theorem]. Its truth can be deduced from the equations of the full https://en.wikipedia.org/wiki/Axiomatic_system[axiomatization] of `obj`. In particular, for types, they are defined relative to other types. Types are a coproduct of either a

. *canonical type* (ctype): a https://en.wikipedia.org/wiki/Primitive_data_type[base/fundamental] type, or a
. *derived type* (dtype): a product of a type and an https://en.wikipedia.org/wiki/Machine_code[instruction] (`inst`).

The ctypes are https://en.wikipedia.org/wiki/Nominal_type_system[nominal types]. There are five ctypes:

. *bool*: denotes the set of booleans -- \$ \mathbb{B} \$.
. *int*: denotes the set of integers -- \$ \mathbb{Z} \$.
. *real*: denotes the set of reals -- \$ \mathbb{R} \$.
. *str*: denotes the set of character strings -- \$ \Sigma^\ast \$.
. *poly*: denotes the set of polynomials (composites) -- \$ \tt{obj}^n \$.

image::type-product.png[float=right,width=295]

The dtypes are https://en.wikipedia.org/wiki/Structural_type_system[structural types] whose https://en.wikipedia.org/wiki/Recursive_data_type[recursive definition]'s base case is a ctype realized via a chain of instructions (`inst`) that operate on types to yield types. The path back to a type's base ctype is called the type's *trace*. Formally, the type coproduct is defined as

\[
\begin{split}
\texttt{type} &=\;& (\texttt{bool} + \texttt{int} + \texttt{real} + \texttt{str} + \texttt{poly}) + (\texttt{type} \times \texttt{inst}) \\ \texttt{type} &=\;& \texttt{ctype} + (\texttt{type} \times \texttt{inst}) \\ \texttt{type} &=\;& \texttt{ctype} + \texttt{dtype}, \end{split}
\]

where each component of the coproduct also has a respective quantifier as previously defined for all `objs`.

A dtype has two \$pi\$-projections. The type projection denotes the https://en.wikipedia.org/wiki/Domain_of_a_function[domain] and the instruction projection denotes the https://en.wikipedia.org/wiki/Function_(mathematics)[function], where the type product as a whole, relative to the component projections, is the https://en.wikipedia.org/wiki/Range_of_a_function[range].
\[
\begin{split}
\tt{type} &=\;& (\tt{type} &\;\times\;& \tt{inst}) &\;+\;& \tt{ctype} \\ \text{â€œrange} &=\;& (\text{domain} &\;\text{and}\;& \text{function}) &\;\text{or}\;& \text{base"} \end{split}
\]

The implication of the dtype product is that mm-ADT types are generated https://en.wikipedia.org/wiki/Inductive_type[inductively] by applying instructions from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (`inst`). The application of an `inst` to a type (ctype or dtype) yields a dtype that is a structural expansion of the previous type.

image::ctype-dtype.png[align=center,width=230]

For example, `int` is a ctype denoting a single `int` value from the set of all integers. When the instruction `[is>0]` is applied to `int`, the dtype `int[is>0]` is formed, where `[is>0]` is https://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugar] for `[is,[gt,0]]`. This dtype is a https://en.wikipedia.org/wiki/Refinement_type[refinement type] that restricts `int` to only those `int` values greater than zero -- i.e., a natural number \$\mathbb{N}^+\$.
In terms of the "__range = domain and function__" reading, when an `int` (*domain*) is applied to `[is>0]` (*function*), the result is an `int` greater than zero (*range*).

image::int_isgt0.png[align=center,width=260]

The diagram above is an instance of a structure that is core to various aspects of mm-ADT including type checking, type inference, compiler optimization, garbage collection, and more. It has a name. It's called a *type graph*.

==== Type Structure

image::obj-full.png[float=right,width=320]

The full `obj` structure thus far is diagrammed on the right and some type examples are presented in `mmlang` on the left.

[source]
----
mmlang> int                                    <1>
==>int
mmlang> int{2}                                 <2>
==>int{2}
mmlang> int{2}[is>0]                           <3>
==>int{0,2}<=int{2}[is,bool{2}<=int{2}[gt,0]]
----
<1> A ctype denoting a single integer stream.
<2> A ctype denoting a stream with two integers.
<3> A dtype denoting a zero, one, or two integers.

The salient features of a type are captured in the psuedo-`mmlang` expression below, where the three projections encode a type's

. *Type signature*: the ctype specification of a type's domain and range (via the \$ \pi_\tt{domai\n} \$ and \$ \pi_\tt{rang\e} \$ projections), and
. *Type definition*: an instruction sequence specifying domain `obj` processes (via the \$ \pi_\tt{i\nsts} \$ projection).

image::type-signature-definition.png[align=center,width=650]

===== Type Signature

Every mm-ADT type can be generally understood as a function that maps an `obj` of one type to an `obj` of another type. A *type signature* specifies the source and target of this mapping, where the _domain_ is the source type and the _range_ is the target type. Both the domain and range type specifications include a respective quantifier denoted `{q}` in `mmlang`.
The general pattern of a type signature is

[.text-center]
`range{q}\<=domain{q}`.

[cols="6,10"]
|===
|mmlang Expression |Description

a|
[source]
----
mmlang> int{1}
==>int
----
|In most programming languages, a value can be typed `int` as in

`val x:int = 10`.

Such https://en.wikipedia.org/wiki/Declaration_(computer_programming)[declarations] state that the value referred to by `x` is a _single_ element within the set of integers. The concept of a "single element" is captured in mm-ADT by the `obj` quantifier, where a https://en.wikipedia.org/wiki/Unit_(ring_theory)[unit] quantifier is not displayed in `mmlang`. That is, `int{1}` is more concisely displayed as `int`.

a|
[source]
----
mmlang> int<=int
==>int
----
|From the perspective of "type-as-function," An mm-ADT `int` is a https://en.wikipedia.org/wiki/NOP_(code)[no-op] on the set of integers. Given any integer, `int` returns that integer. In `mmlang`, when the domain and range are the same, the `\<=` and repeated type are not displayed. That is `int\<=int` is more concisely displayed as `int`.

a|
[source]
----
mmlang> int<=bool
language error: bool is not an int
----
|Type's that are fully specified by their type signature are always canonical types. Therefore, `bool\<=int` is meaningless as there are no instructions to map an `int` to a `bool`.

a|
[source]
----
mmlang> int{5}
==>int{5}
----
|`int{5}` is a type referring to 5 integers. As a point of comparison, `int` refers to a single integer. This is why `int` is syntactic sugar for `int{1}` in `mmlang`.

a|
[source]
----
mmlang> int{0,5}
==>int{0,5}
mmlang> int{0,5}<=int{0,5}
==>int{0,5}
----
|Quantifiers must be elements from a ring with unity. In the previous examples, the chosen quantifier was the integer ring \$\langle \mathbb{Z},+,\times \rangle\$. In this example, the https://en.wikipedia.org/wiki/Algebraic_structure[carrier set] is two integers and represents uncertainty as to the number of elements being referred to. `int{0,5}` is a type referring to either 0, 1, 2, 3, 4, or 5 integers.
|===

===== Type Definition

Types and values both have a *ground* that exists outside of the mm-ADT VM within the hosting environment (e.g. the JVM). The ground of the mm-ADT value `2` is the JVM primitive `2L` (a Java `long`). The ground of the mm-ADT type `int` is the JVM class `java.lang.Long`. When the instruction `[plus,4]` is applied to the mm-ADT `int` value `2`, a new mm-ADT `int` value is created whose ground is the JVM value `6L`. When `[plus,4]` is applied to the mm-ADT `int` type, a new type is created with the same `java.lang.Long` ground. Thus, the information that distinguishes `int` from `int[plus,4]` is in the remembrance of the instruction that was applied to `int`. For a type, this history is called the *type definition* (and more generally, the *type's trace*) and is a subgraph of a larger *type graph*.

NOTE: In practice, the string representation of a value is its _ground_ and the string representation of a type is its _trace_.

image::type-value-trace.png[align=center,width=550]

[source]
----
mmlang> 2[plus,4][is>0]
==>6
mmlang> 2[plus,4][is>0][trace]
==>[2;[plus,4];6;[is,true]]
mmlang> 2[plus,4][is>0][type]
==>int{?}<=int[plus,4][is,bool<=int[gt,0]]
----

Both types and values exist in a larger graph called the *obj graph* for which a type's type graph is a component. In theory, the complete history of an mm-ADT program (from compilation to execution) is stored in this graph. However, in practice, the mm-ADT VM removes those traces (particular paths through the graph) that are no longer required by the program. This process is called *trace retraction* and is the mm-ADT equivalent of https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)[garbage collection].

===== Type Quantification

.Initial and Terminal Objects
****
image::initial.png[width=130,float=left]

A category may have an https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial and/or terminal] object.

An *initial object* \$S\$ is the domain of a set of morphism \$S \rightarrow E_n\$.
Initial objects, via their morphisms, generate all the objects of the category.
If there is an initial object, then it is unique in that if there is another initial object, it has the same diagrammatic topology -- all outgoing morphisms and no incoming morphisms save the identity.
Thus, besides labels, two initials are isomorphic.

image::terminal.png[width=130,float=right]

A *terminal object* \$E\$ is the range of a set of morphisms \$S_n \rightarrow E\$.
Terminal objects subsume all other objects in the category in that all other objects \$S_n\$ can be morphed into the terminal object, but the terminal object can not be morphed into any other object.
Similar to initials, should another terminal exist, the two terminal are isomorphic in that they both have the same number of incoming morphisms and no outgoing morphisms (save the identity).

&nbsp;
****

.Quantifier Symbols in mmlang
[width=35%,cols="1,1,2,float=right]
|===
|usage   |sugar  | unsugared

|https://en.wikipedia.org/wiki/Option_type[none]/nothing   |`{0}`  | `{0,0}`
|https://en.wikipedia.org/wiki/Option_type[some]/just      |       | `{1,1}`
|exact          |`{x}`  | `{x,x}`
|least footnote:order[Applicable to quantifier rings with an total order over the carrier.]         |`{x,}` | `{x,max}`
|most footnote:order[]          |`{,x}` | `{min,x}`
|https://en.wikipedia.org/wiki/Option_type[option]/maybe   |`{?}`  | `{0,1}`
|given footnote:order[]         |`{+}`  | `{1,max}`
|any footnote:order[]           |`{*}`  | `{1,max}`
|===

In order to quantify the _amount_ of values denoted by a type, every mm-ADT type has an associated quantifier `q`. Quantifiers are typically integers, but can be any element from an ordered algebraic https://en.wikipedia.org/wiki/Ring_(mathematics)[ring with unity] (e.g. integers, reals in \$ \mathbb{R}, \mathbb{R}^2, \mathbb{R}^3, \ldots, \mathbb{R}^n \$, unitary matrices, etc.). While integer quantifiers signify "amount," other quantifiers such as https://en.wikipedia.org/wiki/Unitary_matrix[unitary matrices] used in the representation of a https://en.wikipedia.org/wiki/Wave_function[quantum wave function], "amount" is a less accurate description.

Common programming concepts that are usually captured by typeclasses or functors (via https://en.wikipedia.org/wiki/Lift_(mathematics)[lifting]) are expressed in mm-ADT via quantification.

[source]
----
int                               // a single int   (some)
int{?}<=int[is,[gt,0]]            // 0 or 1 int     (option)
int{0}<=int[is,false]             // 0 ints         (none)
int{4}<=int{2}[branch,[id],[id]]  // 4 ints         (exact)
int{*}<=[=db][get,'people']       // 0 or more ints (any)
----

The default quantifier ring of the mm-ADT VM is
\[
\langle \mathbb{N}^+ \times \mathbb{N}^+, \ast, + \rangle,
\]
where \$(1,1)\$ is the multiplicative identity (unity) and \$(0,0)\$ is the additive identity. The \$\ast\$ and \$ +\$ binary operators are pairwise integer multiplication and addition, respectively. In `mmlang` if an `obj` quantifier is not displayed, then the quantifier is assumed to be the unity of the ring, or `{1,1}`. Moreover, if a single value is provided, it is assumed to be repeated where `{n}` is shorthand for `{n,n}`. Thus, `int` is `int{1}`  is `int{1,1}`.

One quantifier serves an important role in mm-ADT as both the additive identity and multiplicative https://en.wikipedia.org/wiki/Annihilator_(ring_theory)[annihilator] -- `{0}`. All `objs` quantified with the respective quantifier ring's annihilator are https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to the https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial object].

NOTE: Types such as `int{0}` and `int{0}\<=int[is>0&&<0]` are isomorphic due to their quantifiers both being `{0}`. Typically, throughout the documentation, both will be referred to simply as `obj{0}` or `{0}` (the *zero object*).

==== Higher Order Types

In mm-ADT, every type \$A\$ is a https://en.wikipedia.org/wiki/Space_(mathematics)[space], where the points of the space are mm-ADT `objs` (types and values). What makes \$A\$ a space as opposed to a structureless set, is the relations linking the `objs` of the type as dictated by semantics of the type. Every mm-ADT type is described by a directed labeled https://en.wikipedia.org/wiki/Multigraph[multigraph] called a *type graph*. If \$x:A\$ and \$y:A\$ are two `objs` in type \$A\$, then a https://en.wikipedia.org/wiki/Path_(topology)[path] \$x \rightarrow_{A} y\$ through the type graph denotes a continuous walk that starts at \$x\$ and ends at \$y\$ https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence[proving] that \$x\$ is \$A\$-equal to \$y\$. For instance, the type

[.text-center]
`int[is,[eq,int]]`

describes a https://en.wikipedia.org/wiki/Reflexive_relation[reflexive graph] whose vertices are integers in `int` and whose edges are labeled `[is,[eq,int]]`. There are other mm-ADT types (an infinite amount in fact) that are related to `int[is,[eq,int]]` by a https://en.wikipedia.org/wiki/Graph_homomorphism[graph homomorphism] defined by another type. A few such types are itemized below.

[source]
----
int[plus,0]
int[mult,1]
int[plus,1][plus,-1]
int[plus,2][plus,-2]
int[plus,3][plus,-3]
...
----

Note a common pattern. The type `int[plus,x:int][plus,x:int[neg]]` captures an infinite number of more specific types that are homomorphic to `int[is,[eq,int]]`. https://en.wikipedia.org/wiki/Higher-order_function[Higher order type] are defined using mm-ADT `polys`.

[.text-center]
`(int[is,[eq,int]])\<=(int[plus,x:int][plus,x:int[neg]])`

In category theory, a _type-to-type_ mapping that https://en.wikipedia.org/wiki/Morphism[preserves structure] is called a https://en.wikipedia.org/wiki/Functor[functor]. From the perspective of mm-ADT, two new "ctypes" are linked in a domain/range `\<=`-relation within a higher-order https://en.wikipedia.org/wiki/Identity_function[identity type] with respective signature. The identity is apparent in that there are no instructions specified to coerce the `objs` of the domain to the `objs` of the range. This is analogous to `int\<=int`, save that equivalence is not predicated on equality nor https://en.wikipedia.org/wiki/Isomorphism[isomorphism], but on a https://en.wikipedia.org/wiki/Surjective_function[surjective] homomorphism. With this broader definition, a new `int` equivalence has been defined.

[source]
----
mmlang> [define,(int[is,[eq,int]])<=(int[plus,x:int][plus,x:int[neg]])]
        [int][plus,10][plus,-10]
==>int[is,[eq,int]]
----

image::type-to-type-type.png[width=700,align=center]

The type `int[is,[eq,int]]` has a https://en.wikipedia.org/wiki/Isomorphism[ismorphic] image in `int`, where the reflexive self-loop paths in `int[is,[eq,int]]` are contracted to 0-length paths. The isomorphism realizes `int` as a classic set without structure as the `int` type definition has no instructions.

[source]
----
mmlang> [define,int<=(int[is,[eq,int]])]
        [define,(int[is,[eq,int]])<=(int[plus,x:int][plus,x:int[neg]])]
        [int][plus,10][plus,-10]
==>int
----

The composition of two structure preserving type morphisms yields a new type--namely, `int\<=(int[plus,x:int][plus,x:int[neg]])`.

.mm-ADT Types are Graphs and their Values Realize Paths
================================================================
In the https://en.wikipedia.org/wiki/Set_theory[set theoretic] interpretation of _types_, the mm-ADT type
 +

`int[is>0]`

would be considered a reasonable type -- it is the set of integers greater than `0`. This type defines a subtype of `int` using a https://en.wikipedia.org/wiki/Predicate_%28mathematical_logic%29[predicate] (\$ \tt{g\t}:\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{B}\$). On the other hand, the type
 +

`int[plus,1]`

would be considered unreasonable as it is a transformation function, not a https://en.wikipedia.org/wiki/Indicator_function[characteristic function]. However, in mm-ADT, _both are types_. An `obj` is a member of a particular type if and only if the type's function (as algorithmically defined by its instructions) _does not_ map the `obj` to the https://en.wikipedia.org/wiki/Initial_and_terminal_objects[terminal] `obj{0}`. If
\[
f: A \rightarrow B
\]
is the function of type `B\<=A[f]`, then
\[
f(a) =
\begin{cases}
b\{*\} & \text{if $a$ is a value of the type},  \\
b\{ 0\} & \text{otherwise.}
\end{cases}
\]

An mm-ADT *type graph* denotes a type whose values are those `objs` that realize a path in that graph.
================================================================

==== Mono Types

.Monoids
****
A https://en.wikipedia.org/wiki/Monoid[monoid] is a structure of the form \$\langle A,\ast \rangle\$, where \$A\$ is the carrier set closed under the associative binary operator \$\ast: A \times A \rightarrow A\$ with \$1 \in A\$ being the https://en.wikipedia.org/wiki/Identity_element[identity] such that for every \$a,b,c \in A\$, \$(a \ast b) \ast c = a \ast (b \ast c)\$ and \$a \ast 1 = 1 \ast a = a\$.
****

An mm-ADT `mono` is the set of all atomic types.

[.small]
[cols="1,3,1,1",width=35%,float=left]
|===
| type | inst                              | 0       |  1

| `bool` | `&&` `\|\|` `-`                 | `false` | `true`
| `int`  | `*` `+` `-` `>` `<` `>=` `\<=`  | `0`     | `1`
| `real` | `*` `+` `-` `>` `<` `>=` `\<=`  | `0.0`   | 1.0
| `str`  | `+` `>` `<` `>=` `\<=`          | `''`    |
|===

'''

===== Bool Type

[source]
----
mmlang> true
==>true
mmlang> true&&false
==>false
mmlang> true[and,false]
==>false
mmlang> true[and,false][neg]
==>true
mmlang> true[and,false][neg][or,false]
==>true
mmlang> bool[and,false][neg][or,false][explain]
==>'
bool[and,false][neg][or,false]

instruction    domain       range  state
-----------------------------------------
[and,false]    bool    =>   bool
[neg]          bool    =>   bool
[or,false]     bool    =>   bool
'
mmlang>
----

===== Int Type

===== Real Type

===== Str Type

==== Poly Types

.Poly Constructs
================================================================
. `[ ]` is a type polynomial.
. `( )` is a value polynomial.
. `lst` is a polynomial with terms indexed by `int`.
. `rec` is a polynomial with terms indexed by `obj`.
. `,` is a polynomial term deliminator denoting parallel compose.
. `|` is a polynomial term deliminator denoting parallel choose.
. `;` is a polynomial term combinator denoting serial compose.
. `-<` is sugar for `[split]` copying the LHS across all polynomial terms.
. `>-` is sugar for `[merge]` joining polynomial terms into a single `obj`.
================================================================

.Rings
****
A ring is an algebraic structure \$ \langle A,\*,\+,1,0 \rangle \$, where \$A\$ is the carrier set, \$\*: A \times A \rightarrow A\$ is the _multiplicative_ operator, \$\+: A \times A \rightarrow A \$ is the _additive_ operator, \$1 \in A\$ is the multiplicative identity, and \$0 \in A\$ is the additive identity.
A ring satisfies the following axioms, where \$ a,b,c \in A \$.

[.small]
[cols="^4,^4,^5"]
|===
| common notation                    | terminology                              | mmlang notation

|\$(a + b) + c = a + (b + c)\$       | additive associativity                   | `\((a,b),c) == (a,(b,c))`
|\$0 + a = a + 0 = a\$               | additive identity                        | `({0},a) == (a,{0}) == a`
|\$a - a = a + (-a) = 0\$            | additive inverses                        | `(a,a{-1}) == {0}`
|\$a + b = b + a\$                   | additive commutativity                   | `(a,b) == (b,a)`
|\$(a * b) * c = a * (b * c)\$       | multiplicative associativity             | `\((a;b);c) == (a;(b;c))`
|\$1 * a = a * 1 = a\$               | multiplicative identity                  | `({1};a) == (a;{1}) == a`
|\$(a + b) * c = (a * c) + (b * c)\$ | multiplicative left distributivity       | `\((a,b);c) == ((a;c),(b;c))`
|\$a * (b + c) = (a * b) + (a * c)\$ | multiplicative right distributivity      | `(a;(b,c)) == \((a;b),(a;c))`
|===

[.small]
[cols="^4,^2,^4"]
|===
| common notation                    | deduction                                | mmlang notation

|\$a + b = a + c \=> b = c\$         | factors                                  |
|\$a + b = 0 \=> a = -b & b = -a\$   | unique inverse                           |
|\$-(a+b) = (-a) + (-b)\$            | distributivity                           | `(a,b){-1} == (a{-1},b{-1})`
|\$-(-a) = a\$                       | distributivity                           | `(a{-1}){-1} == a`
|\$a*0 = 0 = 0*a\$                   | annihilator                              | `(a;{0}) == {0} == ({0};a)`
|\$a * (-b) = -a * b = -(a * b)\$    | factors                                  | `(a;b{-1}) == (a{-1};b) == (a;b){-1}`
|\$(-a) * (-b) = a * b\$             | factors                                  | `(a{-1};b{-1}) == (a;b)`
|===
****

[cols="0,1,2",width=35%,float=right]
|===
| poly |  inst       | + axiom

| `,`  | `[branch]`  | commutative
| `\|` | `[choose]`  | non-commutative
| `;`  | `[compose]` | semi-commutative
|===

A polynomial is a _linear combination_ of _terms_ composed of _coefficients_ and _indeterminates_ typically expressed as \[
p = q_0 x^0 + q_1 x^1 + q_2 x^2 + \ldots + q_n x^n, \]
where \$q_i\$ is a coefficient, \$x^i\$ is an indeterminate, \$q_i x^i\$ is a term, and the terms are linearly combined via `+`.

In mm-ADT, the elements of the set `poly` are https://en.wikipedia.org/wiki/Polynomial[polynomials].
A `poly` is a _decoupling_ of _objs_ composed of _quantifiers_ and _objects_ typically expressed as

[.text-center]
`(x0{q0},x1{q1},x2{q2},...,xn{qn})`

where `qi` is a quantifier, `xi` is an object, `xi{qi}` is an `obj` (type or value), and the `objs` are isolated via `,`.

The set `obj` is a https://en.wikipedia.org/wiki/Tagged_union[disjoint union] of types and values, where \$\tt{type} \rightarrow \tt{obj} leftarrow \tt{value}\$.
The type `objs` are the carrier of a https://en.wikipedia.org/wiki/Ring_(mathematics)[ring with unity] with `[compose]` as multiplication , `[branch]` as addition, `[id]` as the multiplicative identity (*1*), and `[is,false]` as the additive identity (*0*). mm-ADT quantifiers also form a ring with unity, where typically the carrier set is `int` and `+` and `*` are standard integer addition and multiplication, respectively.
A variation of the https://en.wikipedia.org/wiki/Product_ring[direct product] of rings composes the type ring and the quantifier into a new ring called a https://zenodo.org/record/2565243[stream ring], where the carrier set is the set of all quantified types and `[id]{1}` is the multiplicative identity and `[id]{0}` is the additive identity.

image::poly-type-value.png[float=right,width=525]

In mm-ADT, `poly` is formed from the coproduct of `vpoly`, `tpoly`, and `tvpoly`.
The `vpolys` and `tpolys` are data or process https://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29[fixpoints] that exist at the extreme ends of the type/value `obj` coproduct.
Between these extremes are the `tvpolys`.
The `tvpolys` ultimately resolve to a `vpoly` or a `tpoly` fixpoint through the process of https://en.wikipedia.org/wiki/Compiler[compilation] or https://en.wikipedia.org/wiki/Eval[evaluation].
A `tvpoly` can be understood as a process that hasn't terminated (https://en.wikipedia.org/wiki/State_(computer_science)[state]) or as a function equipped with data (https://en.wikipedia.org/wiki/Closure_(computer_programming)[closure]).
Together, these `poly` types are useful as:

. *Data structures* (`vpoly`): Data as the solution to a polynomial, where there no longer exists indeterminates.
. *Process structures* (`tpoly`): Programs as a polynomial containing only indeterminates and thus, may have various value solutions.
. *Computing structures* (`tvpoly`): A computation as a polynomial that hasn't been fully solved and thus, is midway between either a `tpoly` or a `vpoly` fixpoint.

IMPORTANT: mm-ADT provides two convenient type constructors for working with `poly` data structures: `lst` (an `int`-indexed array) and `rec` (an `obj`-indexed array).

A `vpoly` can be understood as a common list containing only values.

[source]
----
mmlang> ('a','b','c')      <1>
==>('a','b','c')
mmlang> (,.)               <2>
==>(,.)
mmlang> ('a',.)            <3>
==>('a',.)
----
<1> A fully reduced three term polynomial.
<2> An empty `,-poly`.
<3> A single term `,-vpoly` also uses a `.` as a terminator token.

The reason for `.` is that the `,-vpoly` below is a two term `poly` with the second term being `obj{0}`.

[source]
----
mmlang> ('a',)
==>('a',)
mmlang> ('a',).1
mmlang> ('a',.).1
language error: poly index is out of bounds: 1
----

A `tpoly` can be understood as either an unordered (`,`) or ordered (`|`, `;`) collection of functions.

[source]
----
mmlang> 3-<([plus,1],[mult,2])   <1>
==>[4,6]
mmlang> 3-<([plus,1]|[mult,2])   <2>
==>[4|]
mmlang> 3-<([plus,1];[mult,2])   <3>
==>[4;8]
----
<1> A polynomial solved as `(3+1,3*2)` (or).
<2> A polynomial solved as `(3+1,obj{0})` (exclusive or).
<3> A polynomial solved as `(3+1,3+1*2)`  (and).

[NOTE]
================================================================
The two terms of the polynomial `\[[gt,0],[gt,10]]` are `_` types (__anonymous types__). Compilation infers the domain/range of the anonymous types.

[source]
----
mmlang> [[gt,0],[gt,10]]
==>bool{2}<=_-<(bool<=_[gt,0],bool<=_[gt,10])>-
mmlang> int[[gt,0],[gt,10]]
==>bool{2}<=int-<(bool<=int[gt,0],bool<=int[gt,10])>-
mmlang> int{5}[[gt,0],[gt,10]]
==>bool{10}<=int{5}-<(bool{5}<=int{5}[gt,0],bool{5}<=int{5}[gt,10])>-
----
================================================================

There are 3 `poly` rings. Each draws from the same `obj` carrier set, but are combined using different "additive" binary operators: `,` (_orThen_), `|` (_xorThen_), and  `;` (_andThen_), where `,` yields a commutative polynomial, `|` yields a non-commutative polynomial and `;` yields a semi-commutative polynomial with "addition" being monoid multiplication. The general form of a `poly` from each of the three polynomial rings is expressed below in `mmlang`.

[.text-center]
`([t0{q0}],[t1{q1}],...,[tn{qn}])` +
`([t0{q0}]|[t1{q1}]|...|[tn{qn}])` +
`([t0{q0}];[t1{q1}];...;[tn{qn}])`


================================================================
The `polys` have two structural representations (a value and a type from) and two `poly`-specific instructions for mapping an `obj` to a `vpoly` and a `vpoly` to an `obj`.
The intution being that these operators transform a serial expression into a parallel expression and vice versa.
Each has a respective `mmlang` syntax sugar that is the preferred notation for all the remaining examples.

. `( )`: The _value_ form of a `poly` is an "atomic" poly that can only be resolved when used in conjection with `poly`-specific instructions/operators.
. `-<`: The _split_ operator is syntax sugar for `poly\<=obj[split,poly]` where the incoming `obj` is cloned across the `poly` terms.
The result is the result of applying the incoming `obj` to each `poly` term in a `poly` of equal size and type.
. `>-`: The _merge_ operator is syntax sugar for `obj{*}\<=poly[merge]` where the incoming `poly` is deconstructed into its component terms, where the resultant `obj's` quantifier is computed the polynomial's summation formula.
. `[ ]`: The _type_ form of a `poly` is a "functional" poly that can be composed with other types, where `[a,b,c]` is equivalent to `-<(a,b,c)>-`.

================================================================

===== orThen ,-poly

A `,-poly` is a polynomial ring with https://en.wikipedia.org/wiki/Commutative_property[commutative] addition defined as

\[
\texttt{t0\{q0\},t1\{q1\}} = \begin{cases}
\texttt{t0\{q0+q1\}} & \text{if } \texttt{t0==t1}, \\ \texttt{t0\{q0\},t1\{q1\}} & \text{otherwise.} \end{cases}
\]

If the indeterminates of two terms are equal, then they can be merged by summing their coefficients.
In the lexicon of mm-ADT, if two types are equal, then their quantifiers can be summed using the additive operator of the respective quantifier ring.
Within the category of the `inst` monoid, the following `mmlang` examples highlight the salient features of `|-poly` addition.

[source]
----
mmlang> 'mar'[branch,[plus,'ko'],[plus,'ko']]     <1>
==>'marko'{2}
mmlang> 'mar'[branch,[plus,'ko']{2}]              <2>
==>'marko'{2}
mmlang> 'mar'[plus,'ko']{2}                       <3>
==>'marko'{2}
mmlang> 'marko'{2}                                <4>
==>'marko'{2}
----
<1> The `'mar'` `str` is copied as input to two `[plus,'ko']` branches.
<2> Branch aggregation by coefficient summation is possible because the two branches are equal.
<3> With only one "branch," the expression can be extracted from `[branch]`.
<4> The expression has reached a fixpoint and thus, is solved.

In the category `poly`, the previous `mmlang` examples are written as follows.

[source]
----
mmlang> 'mar'[[plus,'ko'],[plus,'ko']]
==>'marko'{2}
mmlang> 'mar'[[plus,'ko']{2},.]
==>'marko'{2}
mmlang> [[start,'mar'][plus,'ko'],[start,'mar'][plus,'ko']]
==>'marko'{2}
----

The last expression demonstrates a property of all rings: multiplication both right and left https://en.wikipedia.org/wiki/Distributive_property[distributes] over addition.
\[
\begin{split}
a(b+c) &=& \; ab + ac \\ (b+c)a &=& \; ba + ca \end{split}
\]

[source]
----
mmlang> 'a'[+'b',+'c']
==>'ab'
==>'ac'
mmlang> ['b','c']+'a'
==>'ba'
==>'ca'
----

================================================================
Two `,-poly` terms can be added if their indeterminates are equal.
For the monotypes such as `bool`, `int`, `real`, and `str`, equality is based on the grounded value of the type.
Equality ignores quantification and trace history.

[source]
----
mmlang> 'a'=='a'
==>true
mmlang> 'a'=='ab'
==>false
mmlang> 6==6
==>true
mmlang> 6==6{10}
==>true
mmlang> 6{20}==6{10}
==>true{20}
mmlang>
----

Every type is either a ctype or a dtype.
A ctype does not have a trace.
A dtype's trace is the list of instructions rooted at a ctype.
Type equality is based on ctype and trace equality.

[source]
----
mmlang> (int,.)==(int,.)
==>true
mmlang> (int,.)==(int[plus,10],.)
==>false
mmlang> (int[plus,10],.)==(int[plus,10],.)
==>true
----

In the example below, the two traces are different, but the semantics of the expression are the same.
Thus, as a polynomial, these two terms should be combined.
This is accomplished via a particular type of https://en.wikipedia.org/wiki/Rewriting[rewrite system] for _type rewrites_.
Given a specification of type equivalences (as defined by their trace), `int[plus,10][plus,0]` is rewritten to `int[plus,10]`.
At which point the two types are equivalent and can be merged accordingly.

[source]
----
mmlang> (int[plus,10],.)==(int[plus,10][plus,0],.)
==>false
----
================================================================

===== xorThen |-poly

A `|-poly` is a polynomial ring with non-commutative addition defined as

\[
\texttt{t0\{q0\}|t1\{q1\}} = \begin{cases}
\texttt{t0\{q0\}} & \text{if } x=>\texttt{t0\{q0\}} \notin \texttt{obj\{0\}}, \\ \texttt{t1\{q1\}} & \text{if } x=>\texttt{t1\{q1\}} \notin \texttt{obj\{0\}}, \\ \texttt{obj\{0\}} & \text{otherwise.} \end{cases}
\]

[source]
----
mmlang> 'mar'[choose,[plus,'ko'],[plus,'io']]          <1>
==>'marko'
mmlang> 'mar'[choose,[plus,'ko']{0},[plus,'io']]       <2>
==>'mario'
mmlang> 'mar'[choose,[plus,'ko']{0},[plus,'io']{0}]    <3>
mmlang>
----
<1> The first branch does not yield `obj{0}` so `'ko'` is added to `'mar'`.
The polynomial reduces to `[plus,'ko']`.
<2> The first branch does yield an `obj{0}` and the second does not so `'io'` is added to `'mar'`.
The polynomial reduces to `[plus,'io']`.
<3> Both branches yield an `obj{0}`.
The polynomial reduces to `obj{0}`.

[source]
----
mmlang> 'mar'[[plus,'ko']|[plus,'io']]
==>'marko'
mmlang> 'mar'[[plus,'ko']{0}|[plus,'io']]
==>'mario'
mmlang> 'mar'[[plus,'ko']{0}|[plus,'io']{0}]
mmlang>
----

Every `|-poly` non-commutative addition because the order in which the terms/branches are evaluated determines the result of the computation.
While `,-poly` implements link:https://en.wikipedia.org/wiki/Union_(set_theory)[union], `|-poly` implements link:https://en.wikipedia.org/wiki/Null_(SQL)#COALESCE[coalesce].

===== andThen ;-poly

A `;-poly` is a polynomial ring with semi-commutative "addition," where "addition" is ring multiplication and thus, is monoid multiplication and monoid multiplication is only guaranteed commutative for the _filter-subring_.
Polynomials with this structure are called https://en.wikipedia.org/wiki/Monoid_ring[monoid rings].
In mm-ADT, monoid multiplication is standard type composition and is defined as

\[
\texttt{t0\{q0\};t1\{q1\} = t0;t1\{q0*q1\}} \]

[source]
----
mmlang> 'mar'[compose,[plus,'k']{2},[plus,'o']{3}]  <1>
==>'marko'{6}
mmlang> 'mar'[compose,[plus,'k']{2},[plus,'o']{0}]  <2>
mmlang>
----
<1> The two branches are serially composed to create a single "branch" with a quantifier that is the product of the two original branch quantifiers.
<2> The two branches are serially composed, but the second branch has a `0`-quantifier and thus, the resolution goes to `obj{0}` as `2 * 0 = 0`.

[source]
----
mmlang> 'mar'[[plus,'k'];[plus,'o']]
==>'marko'
mmlang> 'mar'[[plus,'k'];[plus,'o']{0}]
mmlang>
----

[NOTE]
================================================================
The `[compose]` instruction is a https://en.wikipedia.org/wiki/Higher-order_function[higher-order instruction] that yields the same result as fundamental instruction composition/concatenation.

[source]
----
mmlang> 'mar'[plus,'k']{2}[plus,'o']{3}
==>'marko'{6}
mmlang> 'mar'[plus,'k']{2}[plus,'o']{0}
mmlang>
----

Moreover, a `poly` can be inspected using standard list instructions. Below demonstrates that the `;-poly[merge]` (`>-`) is equivalent to `;-poly[last]`.


[source]
----
mmlang> 'mar'-<([plus,'k'];[plus,'o'])
==>['mark';'marko']
mmlang> 'mar'-<([plus,'k'];[plus,'o'])>-
==>'marko'
mmlang> 'mar'-<([plus,'k'];[plus,'o'])[last]
==>'marko'
----
================================================================

====== Poly Domain Instructions

A `poly` has various interpretations including: https://en.wikipedia.org/wiki/List_(abstract_data_type)[list], https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics)[vector], https://en.wikipedia.org/wiki/Array_data_structure[array], and program.
The table below presents the set of instructions whose domain is `poly`.

[cols="1,1,1,1,5,8",width=100%]
|===
| inst     |  arg(s)   | range  | style | description | mmlang vpoly example

| `[plus]` | `poly`    | `poly` | list  | term expression concatenation
a|
[.small]
[source]
----
mmlang> ('a','b')+('c','d')
==>('a','b','c','d')
----
| `[mult]` | `poly`    | `poly` | vector | https://en.wikipedia.org/wiki/Dot_product[dot product] that is distributive over addition via https://en.wikipedia.org/wiki/FOIL_method[FOIL]
a|
[.small]
[source]
----
mmlang> ('a','b')*('c','d')
==>(('a','c'),('a','d'),('b','c'),('b','d'))
----
| `[hmult]` | `poly`  | `poly`  | vector | https://en.wikipedia.org/wiki/Hadamard_product_(matrices)[Hadamard] pairwise product
a|
[.small]
[source]
----
mmlang> ('a','b')=('c','d')
==>('c','d')
----
| `[head]` |          | `obj`   | list   | the first term of the polynomial
a|
[.small]
[source]
----
mmlang> ('a','b')[head]
==>'a'
mmlang> (,.)[head]
language error: empty polys do not have heads
----
| `[tail]` |          | `poly`  | list   | the polynomial without the first term
a|
[.small]
[source]
----
mmlang> ('a','b')[tail]
==>('b'.,)
mmlang> (,.)[tail]
language error: empty polys do not have tails
----
| `[last]` |          | `obj`  | list   | the last term of the polynomial
a|
[.small]
[source]
----
mmlang> ('a','b')[last]
==>'b'
mmlang> (,.)[last]
language error: empty polys do not have lasts
----
| `[get]`  | `int`     | `obj`   | array | term access by index
a|
[.small]
[source]
----
mmlang> ('a','b','c').1
==>'b'
mmlang> ('a','b','c').3
language error: poly index is out of bounds: 3
----
| `[put]`  | `int,obj` | `poly`  | array | term insertion term by index
a|
[.small]
[source]
----
mmlang> ('a','b','c')[put,1,'ab']
==>('a','ab','b','c')
mmlang> ('a','b','c')[put,5,'e']
==>('a','b','c',,'e')
----
|===

====== Split and Merge

[cols="1,1,1,5,8",width=100%]
|===
| inst     |  arg(s)   | range  | description | mmlang vpoly example

| `[split]`  | `poly` | `poly`  |
a|
[source]
----
mmlang> -<('a','b','c')
==>('a','b','c')
----
| `[merge]`  |        | `obj`  |
a|
[source]
----
mmlang> -<('a','b','c')>-
==>'a'
==>'b'
==>'c'
----
|===

'''

[.small]
[cols="4,1,9",width=46%,float=left]
|===
| poly op         | mmlang      | example

| `;`-*apply*  | `-<(;)`
a|
[source]
----
mmlang> 6-<(_;_)
==>(6;6)
mmlang> 6-<(_+1;_>6)
==>(7;true)
----
| `,`-*copy*   | `-<(,)`
a|
[source]
----
mmlang> 6-<(_,_)
==>(6,6)
mmlang> 6-<(_>0,_>8)
==>(true,false)
----
| `\|`-*pick*  | `-<(\|)`
a|
[source]
----
mmlang> 6-<(_\|_)
==>(6\|)
mmlang> 6-<(_>0\|_>8)
==>(true\|)
----
|===

[.small]
[cols="4,1,9",width=46%,float=right]
|===
| poly op            | mmlang      | example

| `;`-*return*     | `(;)>-`
a|
[source]
----
mmlang> 6-<(_;_)>-
==>6
mmlang> 6-<(_+1;_>6)>-
==>true
----
| `,`-*merge*      | `(,)>-`
a|
[source]
----
mmlang> 6-<(_,_)>-
==>6{2}
mmlang> 6-<(_>0,_>8)>-
==>true
==>false
----
| `\|`-*coalesce*  | `(\|)>-`
a|
[source]
----
mmlang> 6-<(_\|_)>-
==>6
mmlang> 6-<(_+1\|_>6)>-
==>7
----
|===

'''

===== Poly Patterns

====== Records

The examples thus far have used the `lst` version of `poly`. The slots of a `lst` `poly` are indexed by `int` (ordered from 0 to \$n\$). For complex `poly` structures such as nested `polys` or `polys` with many slots, working with `int` indices is cumbersome and error prone. The `rec` `polys` alleviate the problem while providing added expressivity. The slots of a `rec` are indexed by an arbitrary `obj` key.

NOTE: A `lst` is analogous to a https://en.wikipedia.org/wiki/List_(abstract_data_type)[list] or https://en.wikipedia.org/wiki/Array_data_structure[array] and a `rec` is analogous to a https://en.wikipedia.org/wiki/Record_%28computer_science%29[record] or https://en.wikipedia.org/wiki/Hash_table[map].

There are three primary use cases for `rec`.

. Labeling `poly` indices.
+
[source]
----
mmlang> ('marko',29)
==>('marko',29)
mmlang> ('marko',29).0                    <1>
==>'marko'
mmlang> ('marko',29).1
==>29
mmlang> ('name'->'marko','age'->29)
==>('name'->'marko','age'->29)
mmlang> ('name'->'marko','age'->29).name  <2>
==>'marko'
mmlang> ('name'->'marko','age'->29).age
==>29
----
<1> The slots of a "person" `lst` are accessed with `int` values.
<2> The slots of a "person" `rec` are accessed with `str` values.
+
. Accessing multiple slots at a time.
+
[source]
----
mmlang> ('a'->1,'b'->2,'c'->3,'d'->4)
==>('a'->1,'b'->2,'c'->3,'d'->4)
mmlang> ('a'->1,'b'->2,'c'->3,'d'->4)[get,is>'a']
==>2
==>3
==>4
mmlang> ('a'->1,'b'->2,'c'->3,'d'->4)[get,is>'b']
==>3
==>4
mmlang>
----
+
. Branching with predicates.
+
[source]
----
mmlang> 1,2,3-<(is==2 -> 'name' | is>2 -> 'is' | int -> 'my')
==>(->|1->'my')
==>(2->'name'|->)
==>(->|3->'is')
mmlang> 1,2,3-<(is==2 -> 'name' | is>2 -> 'is' | int -> 'my')>-
==>'my'
==>'name'
==>'is'
----

================================================================

The `poly` `recs` are ordered. Even though slots can be uniquely identified by their `obj`-key, equality is dependent on position.

[source]
----
mmlang> (1->'a',2->'b')==(1->'a',2->'b')
==>true
mmlang> (1->'a',2->'b')==(2->'b',1->'a')
==>false
----

Order-based equality ensures the semantics of `;-rec` and `|-rec`, which are non-commutative. The `rec` that is generated from a `-<` split has both the keys and the slots resolved according to the rules of _juxtaposition_ . If two keys yield the same result, then their slots are merged as specified by the `poly` summation operator.


image::rec-orders.png[width=600,align=center]

[source]
----
mmlang> 23-<(is>10->'a',int->'b')
==>(23->'b','a')
mmlang> 23-<(is>10->'a'|int->'b')
==>(23->'a'|->)
mmlang> 23-<(is>10->'a';int->'b')
==>(23->'b')
----

================================================================

====== Lists

====== Stream Containers

====== {0,1}-Boolean Matrices

Hadamard pair-wise product can be used to filter specific terms out of a `poly` in a manner analogous to \$\{0,1\}\$-boolean matrices in https://en.wikipedia.org/wiki/Linear_algebra[linear algebra].
As values do not pass through values, `[hmult]` is provided a `tpoly` where the slots to filter have a `{0}` quantification (e.g., `obj{0}`) and the slots to keep should maintain an identity (e.g. `[id]` or `[noop]`).

[source]
----
mmlang> ('a','b','c')=(obj{0},obj{0},str[id])   // <1>
==>(,,'c')
mmlang> ('a','b','c')=(,,str[id])               // <2>
==>(,,'c')
mmlang> ('a','b','c')=(,,_[id])                 // <3>
==>(,,'c')
mmlang> ('a','b','c')=(,,_)                     // <4>
==>(,,'c')
----

<1> A fully typed \$\{0,1\}\$-polynomial.
<2> An empty slot is `mmlang` sugar for `obj{0}`.
<3> The anonymous type `_[id]` is compiled to `str[id]`.
<4> The anonymous type `_` is compiled to `str` (i.e. `str[noop]`).

The https://en.wikipedia.org/wiki/Identity_matrix[identity matrix] is a \$\{0,1\}\$-matrix that when multiplied using standard matrix product, the result is equivalent to `[id]`.

\[
\begin{pmatrix}
1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ \end{pmatrix}
\cdot \begin{pmatrix}
1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{pmatrix}
= \begin{pmatrix}
1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ \end{pmatrix}
\]

However, with pair-wise product, only the main diagonol remains.

\[
\begin{pmatrix}
1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ \end{pmatrix}
\bullet \begin{pmatrix}
1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{pmatrix}
= \begin{pmatrix}
1 & 0 & 0 \\ 0 & 5 & 0 \\ 0 & 0 & 9 \\ \end{pmatrix}
\]

[source]
----
mmlang> ((1,2,3),(4,5,6),(7,8,9))=(=(_,,),=(,_,),=(,,_))
==>((1,,),(,5,),(,,9))
mmlang> ((1,2,3),
         (4,5,6),
         (7,8,9))
         =
        (=(_,,),
         =(,_,),
         =(,,_))
==>((1,,),(,5,),(,,9))
----

====== Meta-Programming

=== Language Algebras

The mm-ADT VM is a computing machine founded on a non-commutative https://en.wikipedia.org/wiki/Polynomial_ring[polynomial] ring called a _stream ring_. The practical mental-model that mm-ADT purports is that of streams of data flowing through functions (instructions) composed serially (`*`) and in parallel (`+`). Moreover, these streams can be split and merged via the product and coproduct of _streams_ of data whose size and dynamics are regulated by the coefficients (or quantifiers) of the respective polynomial ring. The physical manifestation of this algebra is manipulated by `mmlang`. However, there are two other intervening algebras (at the processor and storage levels), where ultimately, the `mmlang` https://ncatlab.org/nlab/show/Ab-enriched+category[ringoid] realizes a correspondence by means of a https://en.wikipedia.org/wiki/Module_(mathematics)[ring action] upon a https://en.wikipedia.org/wiki/Magma_%28algebra%29[magma].

. *Obj Magma* (_storage_): The set of all `objs` along with a single, non-associative binary _juxtaposition_ operator (denoted with a blank space).
+
\[
\mathbf{Obj} = \langle \texttt{obj}, \;\; \rangle
\]
+
. *Inst Monoid* (_processor_): A nested monoid with an associative, non-commutative binary _next_ operator that corresponds to the processor's https://en.wikipedia.org/wiki/Instruction_pipelining[instruction pipeline].
+
\[
\mathbf{Inst} = \langle \texttt{inst}, *, 1, 0 \rangle
\]
+
. *Trace Ringoid* (_language_): A generalization of the `inst` monoid that supports the composition of polynomials for the construction of serial (`*`), parallel (`+`), and parallel choice (`|`) pipelines, where \$ \mathbf{Inst} \subset \mathbf{Trace} \$. However, there exists an information preserving https://en.wikipedia.org/wiki/Automorphism[automorphism] from \$\mathbf{Trace}\$ to \$\mathbf{Inst}\$ (a self https://en.wikipedia.org/wiki/Embedding[embedding]). This generalization provides greater flexibility for expressing a wider range of common computational patterns.

\[
\textbf{Trace} = \langle \texttt{inst} \cup \texttt{poly}, *, +, |, 1, 0 \rangle
\]

==== Obj Magma

A https://en.wikipedia.org/wiki/Magma_(algebra)[magma] is a non-associative algebraic structure with a single binary operator. Let
\[
\mathbf{Obj} = \langle \texttt{obj}, \;\; \rangle
\]
be a magma with `obj` denoting the set of all quantified mm-ADT objects and \$ : \tt{obj} \times \tt{obj} \rightarrow \tt{obj}\$ the binary _juxtaposition_ operated (denoted by a blank space). There are four types of juxtaposition:

. A **type juxtaposed to a value** yields the value whose quantifier is multiplied by the type's quantifier.
+
[.text-center]
`t1{q0}\<=t0[a][b] v2{q1}` = `v2{q0*q1}`
+
. A **type juxtaposed to a type** yields a type whose domain is the left type's domain and whose range is the right type's range, where instructions are concatenated (juxtaposed) and respective quantifiers multiplied.
+
[.text-center]
`t1{q0}\<=t0[a][b] t2{q2}\<=t1[c][d]` = `t2{q0*q1}\<=t0[a][b][c][d]`
+
. A **value juxtaposed to a type** yields an `obj` (typically a value) that is the application of the type to the value.
+
[.text-center]
`v0{q0} t2{q1}\<=t1[a][b]` = `b(a(v0)){q0*q1}`
+
. A **value juxtaposed to a value** yields the right hand value with quantifiers multiplied.
+
[.text-center]
`v0{q0} v1{q1}` = `v1{q0*q1}`

This is the simplest algebraic structure describing mm-ADT. This interpretation of mm-ADT pushes the rules of branching and its additive effects on quantification to the type and thus, to the respective `[branch]` and `[choose]` instructions contained therein. The one non-associative context that renders the algebra a magma is the three element juxtaposition of `type value type`, where it is generally true that

[.text-center]
`(t0 v1) t2` \$ne\$ `t0 (v1 t2)`.

==== Inst Monoid

mm-ADT types serve numerous roles which are typically realized by many different sorts of objects in traditional programmable systems.
The reason for this singular use is quite literally because the mm-ADT type system (and value system) is inductively generated from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] which is the https://en.wikipedia.org/wiki/Generator_(mathematics)[generator set] of the _syntactic_ **inst monoid** \[
\langle\texttt{inst},\ast\rangle, \]
where \$\tt{i\nst}\$ is the infinite set of all instruction compositions, \$\ast: \tt{i\nst} \times \tt{i\nst} \rightarrow \tt{i\nst}\$ an associative binary composition operator, and \$\tt{[no\op]} \in \tt{i\nst}\$ is the unique identity element.
This "instruction-only" interpretation of mm-ADT realizes the general unitary form of mm-ADT \$ f: S \rightarrow E \$ where `S` is `obj{0}` (i.e. nothing).
The `x\<=[start,x]` instruction is an *initial instruction* in that it returns it's arguments regardless of the input `obj` (or lack thereof).

\[
\texttt{[start,x]}: \texttt{obj\{0\}} \rightarrow \texttt{x}
\]

An mm-ADT program is a _type_, not a composition of instructions (\$ \tt{type} = (\tt{type} \times \tt{i\nst})\$).
The way in which a dtype can be ground to a ctype using instructions only is via the `[start]` instruction.
A single pass through the mm-ADT compiler yields a type trace based at a ctype.

image::start-ctypes.png[float="right",width=315]

[source]
----
mmlang> [start,int]
==>int
mmlang> [start,int][plus,5]
==>int[plus,5]
mmlang> [start,int][plus,5][gt,10]
==>bool<=int[plus,5][gt,10]
mmlang>
----

The `[noop]` instruction is the only mm-ADT instruction that does not alter the state of the `obj` trace graph and thus, the state of the computation.
The instruction `[id]`, on the other hand, does.

[source]
----
mmlang> [start,int][plus,5][gt,10][noop]
==>bool<=int[plus,5][gt,10]
mmlang> [start,int][plus,5][gt,10][id]
==>bool<=int[plus,5][gt,10][id]
----

==== Type Ringoid

.Stream Ring Theory
****
https://zenodo.org/record/2565243[Stream ring theory] is a ring algebra defined by the https://en.wikipedia.org/wiki/Product_ring[direct product] of a *function* and *coefficient* ring, where every function/coefficient pair is an element of the carrier of a polynomial *stream* ring.
The algebra is useful in asynchronous distributed computing environments that primarily enjoy https://en.wikipedia.org/wiki/Embarrassingly_parallel[embarrassingly parallel] processing, but where, at certain space and time https://en.wikipedia.org/wiki/Bulk_synchronous_parallel[synchronization] points, large amounts of data need to be co-located for processing.
A proto-version of the stream ring algebra was realized in the distributed graph computing framework http://tinkerpop.apache.org[Apache TinkerPop].

mm-ADT adopts the algebra of stream ring theory, where functions are *instructions* and coefficients are *quantifiers*. mm-ADT's type system is realized as a https://en.wikipedia.org/wiki/Many-sorted_logic[multi-sorted] extension of the algebra.
****

mm-ADT's type system is founded on a multi-sorted https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] with https://en.wikipedia.org/wiki/Unit_(ring_theory)[unity] called the mm-ADT *type ringoid*.
An algebraic ring is composed of a multiplicative monoid \$\langle A,\ast,1 \rangle\$ and a commutative additive group \$\langle A,\+,0\rangle\$ that share the same carrier set \$A\$.
A https://ncatlab.org/nlab/show/Ab-enriched+category[ringoid] generalizes the mathematics of a ring to support the ring axioms on multi-sorted carriers \$A,B,C\$, etc. (i.e. typed structures).
The mm-ADT type ringoid https://en.wikipedia.org/wiki/Generator_(mathematics)[generator] is the set of all ctypes and single instruction dypes covering `inst`, where, with the ringoid's multiplicative operator (`*`) and commutative additive operator (`+`), when faithfully applied according to sort, induce the set of all possible mm-ADT types.

* The *additive operator* `+` is structurally encoded using a `,-poly`, where each slot of the polynomial is an independent parallel type.
* The *multiplicative operator* `*` is structurally encoded using a `;-poly`, where each slot of the polynomial is a dependent serial type.
* The *additive identity* `0` is the polymorphic anonymous ctype `_{0}`.
* The *multiplicative identity* `1` is the polymorphic anonymous ctype `\_{1}`, which in `mmlang` is simply denoted `_`.

NOTE: The algebra underlying most type theories operate as a https://en.wikipedia.org/wiki/Semiring[semiring(oid)], where the additive component is a https://en.wikipedia.org/wiki/Monoid[monoid] as opposed to an invertible https://en.wikipedia.org/wiki/Group_(mathematics)[group].
In mm-ADT, the elements of the additive component can be inverted by their corresponding _negative type_ (or negative `obj` in general).
Thus, mm-ADT realizes an additive https://en.wikipedia.org/wiki/Groupoid[groupoid], where, for example, the `,-poly` `[int{1},int{-1}]` merges to `int{0}` which is isomorphic to the initial `obj{0}`.

===== The Free Poly Monoid

Every corresponding `mmlang` expression makes use of `poly`-types.
In `mmlang`, a `poly` can be denoted as a _structure_ via `[ ]` (a value) or as a _process_ via `< >` (a type).
The example 3-slot `int` `,-poly` below has a domain of `int` and a range of `int{1,3}`.
This branch structure will product one, two, or three `ints` given a single `int`.

[source]
----
mmlang> int[int[is>0],int[is<0],int]
==>int{1,3}<=int-<(
     int{?}<=int[is,bool<=int[gt,0]],
     int{?}<=int[is,bool<=int[lt,0]],
     int
   )>-
----

[.small]
[cols="1,1,1,1",width=30%,float=left]
|===
| op       | poly | inst        |  meta

| \$\ast\$ | `;`  | `[compose]` | `[mult]`
| \$+\$    | `,`  | `[branch]`  | `[plus]`
| \$o+\$   | `\|` | `[choose]`  | `[plus]`
|===

An mm-ADT `poly` (https://en.wikipedia.org/wiki/Polynomial[polynomial]) is an element of either a _serial_ (`;`), _parallel_ (`,`), or _choice_ (`|`) https://en.wikipedia.org/wiki/Free_object[free] https://en.wikipedia.org/wiki/Trace_monoid[trace monoid] that is https://en.wikipedia.org/wiki/Adjoint_functors[left-adjoint] to a respective \$langle \tt{obj},\tt{[compose] \rangle\$, \$langle \tt{obj},\tt{[branch]} \rangle\$, or \$langle \tt{obj}, \tt{[cho\ose]} \rangle\$ non-free, reductive monoid.
The _nabla functions_, \$\nabla: \text{-poly} \rightarrow \tt{obj} \$, folds a free `poly` structure into an `obj{*}` via the applications of the reducing monoid's operator in `inst` such that \[
\begin{split}
\nabla^;(\texttt{poly}) &=& \texttt{[compose}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=\prod_{i<n} q_i, \\ \nabla^,(\texttt{poly}) &=& \texttt{[branch}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=\sum_{i<n} q_i, \\ \nabla^|(\texttt{poly}) &=& \texttt{[choose}, \texttt{poly}^{q_0}_0, \texttt{poly}^{q_1}_1,\ldots, \texttt{poly}^{q_n}_n,\texttt{]} \text{ with } q=(\min_{i<n}(q_i),\max_{i<n}(q_i)), \end{split}
\]
where \$\nabla\$ is realized as the https://ncatlab.org/nlab/show/codiagonal[codiagonal] `>-` (i.e. `[merge]`) instruction. the resultant `obj` is quantified within the specified `q` range.
This is the general solution to deriving the type quantifier during compilation and can be further refined using instruction semantics.
The following diagrams specify three https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms[monoid homomorphisms] that couple the `poly` to `inst` monoids such that the underlying monoidal processes of the mm-ADT VM can be directly manipulated by any mm-ADT language that supports `poly` -- e.g., within `mmlang`.

'''
image::free-monoid-homomorphisms.png[align=center]
'''

Both the `-poly` and \$\langle \tt{obj},- \rangle\$ monoids derive their https://en.wikipedia.org/wiki/Algebraic_structure[carrier sets] from the https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial] set of mm-ADT `objs`.
The injective _delta functions_, \$\Delta:\tt{obj} \rightarrow \text{-poly}\$, yield the https://en.wikipedia.org/wiki/Generator_(mathematics)[generators] of the `-poly` monoid's, where \[
\begin{split}
\Delta^{;}(\texttt{obj}) &=& [\texttt{obj};], \\ \Delta^{,}(\texttt{obj}) &=& [\texttt{obj},], \\ \Delta^{|}(\texttt{obj}) &=& [\texttt{obj}|], \end{split}
\]
and \$\Delta\$ the https://en.wikipedia.org/wiki/Diagonal_morphism[diagonal] `-<` (i.e. `[split]`) instruction.
Likewise, `[compose]`, `[branch]`, and `[choose]` are the instruction representations of the composition of `objs`.
If \[
\begin{split}
U: M \rightarrow \textbf{Set}
\end{split}
\]
maps a monoid to its carrier set, then the diagrams below commute, where the https://en.wikipedia.org/wiki/Universal_property[universal property] of monoid mappings is realized as the "lifted" `poly` syntactic category encoding of the mm-ADT https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture].

image::monoid-homomorphisms.png[align=center]

The following diagrams detail the operational semantics of the mm-ADT VM with respects to the coupling between the corresponding free and reductive monoids.
The dashed lines provide a disentangled, parallel (product) view of the respective double-line compositions.
Finally, the squiggly line joining the two parallel morphisms in the `|-poly` diagram makes clear that, unlike the branches in `,-poly` these branches are coupled to ensure the proper https://en.wikipedia.org/wiki/Tagged_union[sum type] (disjoint union) semantics of the _either_ https://en.wikipedia.org/wiki/Coproduct[coproduct].

[cols="3,^9"]
|===
| `;-poly`
\[
\left(\Delta^; \circ \left(f \ast g\right) \circ \nabla^; \right)
\]
andThen/compose-chain +
dependent slots +
product +
\$A \ast B \implies C\$
| image:semi-delta-nabla.png[width=455,link=images/language/semi-delta-nabla.png]

| `,-poly`
\[
\left(\Delta^, \circ \left(f+g\right) \circ \nabla^,\right)
\]
copy/clone-branching +
independent slots +
product +
\$A+A \implies 2A\$
| image:comma-delta-nabla.png[width=455,link=images/language/comma-delta-nabla.png]


| `\|-poly`
\[
\left(\Delta^\| \circ \left(f \oplus g\right) \circ \nabla^\|\right)
\]
either/choice-branching +
dependent slots +
coproduct +
\$A \oplus A \implies A\$
| image:pipe-delta-nabla.png[width=455,link=images/language/pipe-delta-nabla.png]
|===

===== Free Type Ringoid

The two `;,-poly` monoids serve as components of a https://en.wikipedia.org/wiki/Universal_algebra[universal algebra] that implements the https://zenodo.org/record/2565243[stream ring] algebra -- the foundational algebra of the mm-ADT VM. The two `poly` monoids form a https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] and thus, a syntactic https://en.wikipedia.org/wiki/Free_algebra[free algebra] that enables mm-ADT https://en.wikipedia.org/wiki/Metaprogramming[metaprogramming] by way of a https://en.wikipedia.org/wiki/Ring_homomorphism[ring homomorphism] from the *structural* `;,-poly` free ring to the corresponding reductive *procedural* ring such that \[
;,-\texttt{poly}  \xrightarrow{\;\;\;\nabla^{;}\;\;\;} \langle \texttt{obj},\texttt{[compose][branch]}, \rangle \]
where the _branch_ component is, in fact, a group with `(a{q},a{-q}) == {0}` and `[branch,a{q},a{-q}] == {0}`.

[source]
----
mmlang> -<('a'{2},'a'{-2})
==>['a'{2},'a'{-2}]
mmlang> -<('a'{2},'a'{-2})>-
mmlang>
mmlang> [branch,['a'{2},'a'{-2}]]
mmlang>
----

The `|-poly` can be appended to the `;,-poly` ring, where it serves as an https://en.wikipedia.org/wiki/Idempotence[idempotent] variation of the additive group commonly used to denote https://en.wikipedia.org/wiki/Tagged_union[sum types].

In terms of the mm-ADT VMs component architecture, this ring homomorphism maps a *language* to a *processor* through the common communication medium of `objs` provided by *storage*.
All mm-ADT compliant components are faithful to `obj` and the stream ring axioms that bind them regardless of their particular ring encoding.
In this way, the mm-ADT VM remains agnostic to the specifics of the component implementations and thus, mm-ADT supports the creation of _synthetic data systems_.

image::ring-homomorphisms.png[align=center,width=320]
