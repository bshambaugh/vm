:imagesdir: ./images/introduction
image::mm-adt-logo.png[mm-ADT Logo,float="left",width=150]

http://mm-adt.org[mm-ADT] is a dual licensed https://www.gnu.org/licenses/agpl-3.0.txt[AGPL3]/commercial open source project that offers software engineers, computer scientists, mathematicians, and others in the software industry a royalty-based OSS model.
The Turing Complete mm-ADT virtual machine (VM) integrates disparate data technologies via algebraic composition, yielding _synthetic data systems_ that have the requisite computational power and expressivity for the problems they were designed to solve.
As an economic model, each integration point offers the respective development team access to the revenue streams generated by any for-profit organization leveraging mm-ADT.

== Virtual Machine Components

[ditaa,"vm-components",align="center",float="right",shadows=false]
....
  /---------------------\
  |            mmADT VM |
  |                     |
  | bool,int,str,rec,.. |
  | strm,model,...      |
  | map,filter,branch,..|
  |                     |
  \-----*----*-----*----/
        |    |     |
    /---/    |     \-----\
    |        |           |
+---*----+ +-*-----+ +---*-----+
|{d}     | |  {s}  | | {io}    |
|        | |       | |         |
|language| |storage| |processor|
|        | |       | |         |
+--------+ +-------+ +---------+
....

The mm-ADT VM is the integration point for the following data processing technologies:

* *Programming Languages*: Language designers can create custom languages or develop parsers for existing languages that compile to mm-ADT VM bytecode (binary machine code) or unicode (text assembly code).
* *Processing Engines*: Processor developers enable their push- or pull-based execution engines to be programmed by any mm-ADT language for evaluation via mm-ADT's abstract execution model for processing data structures via single-machine, multi-threaded, agent-based, distributed near-time, and/or cluster-oriented, batch-analytic processors.
* *Storage Systems*: Storage engineers can embed their systems using _model-ADT_ functors expressed in mm-ADT's dependent type system that enable the lossless encoding of key/value store, document store, wide-column store, graph store, relational store, and other novel or hybrid structures such as hypergraph, docu-graph, and quantum data structures.

The mm-ADT VM enables the intermingling of any language, any processor, and any storage system, that can faithfully implement the core language semantics (__types and values__), processor semantics (__process trace graphs__), and/or storage semantics (__data structure streams__).

=== The mm-ADT Algebras

==== The Universal Unary Function

Every mm-ADT program denotes a single https://en.wikipedia.org/wiki/Unary_function[unary function] that maps an `obj` of type \$S\$ (start) to an `obj` of type \$E\$ (end) with the function signature

\[
f: S \rightarrow E.
\]

The complexities of mm-ADT are realized in the definition of an `obj` (which includes both types and values) and the internal structure of an \$f\$-program (which is a composition of nested-functions of arbitrary arity that are https://en.wikipedia.org/wiki/Currying[curried] at either compile-time or runtime).
The sole purpose of this documentation is to make salient the various algebraic structures that are operationalized to ultimately yield the mapping \$f : S \rightarrow E\$.

==== Component Categories and their Functors

[cols="3,3",width=40,float=right]
|===
| Component | Algebra

| Language  | instruction monoid
| Storage   | ADT functors
| Processor | stream ring
|===

Each of the three aforementioned mm-ADT VM components has an associated axiomatic algebra that best describes it's structures and processes.
The *language algebra* is a https://en.wikipedia.org/wiki/Monoid[monoid] that captures the serial composition of instructions from the mm-ADT instruction set architecture.
The *processor algebra* (for both compilation and evaluation) is a https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] capturing serial and parallel function evaluation on objects that represent types and values.
Finally, the *storage algebra* is a suite of categorical https://en.wikipedia.org/wiki/Functor[functors] that map the mm-ADT VM's language and processing algebras to common abstract data types that best represent the interfacing storage systems (e.g. key/value, graph, relational, etc.).

Each of these algebraic structures has a respective categorical encoding and, for each category, there exists a bijective functor to the other two categories such that diagram below commutes.

image::mmadt-algebras.png[align=center,width=250]

The primary purpose of this documentation is to explain these categories algebraically, their intra-category functors, and the respective software technology that enables their real-world manifestation.
Data technology developers will learn how to integrate their technology with any of the aforementioned categories so end users may compose their system with other systems to create mathematically sound _synthetic data systems_ tailored to their problem's particular computational requirements.

=== The mm-ADT Console

The mm-ADT VM provides a https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop:[REPL] console for users to evaluate mm-ADT programs written in any mm-ADT language.
The reference language distributed with the VM is called `mmlang`. `mmlang` is a low-level, functional language that is in near 1-to-1 correspondence with the underlying VM architecture -- offering it's users https://en.wikipedia.org/wiki/Turing_completeness[Turing-Complete] expressively when writing programs and an interactive teaching tool for studying the mm-ADT VM.

[source,text]
----
~/mm-adt bin/mmadt.sh
                                _____ _______
                           /\  |  __ |__   __|
 _ __ ___  _ __ ___ _____ /  \ | |  | | | |
| '_ ` _ \| '_ ` _ |_____/ /\ \| |  | | | |
| | | | | | | | | | |   / ____ \ |__| | | |
|_| |_| |_|_| |_| |_|  /_/    \_\____/  |_|
                                 mm-adt.org
mmlang>
----

A simple console session is presented below, where the parser expects programs written in the language specified left of the `>` prompt.
All the examples contained herein are presented using `mmlang`.

[source]
----
mmlang> 1
==>1
mmlang> +2
==>[plus,2]
mmlang> 1+2
==>3
mmlang> 1[plus,2]
==>3
----

==== mmlang Syntax and Semantics

The https://en.wikipedia.org/wiki/Context-free_grammar[context-free grammar] for `mmlang` is presented below.

[cols="1m,3m,5"]
|===
|token | structure | description

|obj   | (type \| value){q}                           | an `obj` is either a type or a value and a quantifier (`obj=(type + value){q}`)
|type  | ctype \| dtype                               | a type is a ctype or a dtype (`type = ctype + dtype`)
|ctype | bool \| int  \| real \| str \| poly \| _     | a canonical type by which refined and dependent types are built
|poly  |  lst \| inst \| rec                          | polynomials are composite structures with an internal semantics that reflects the process algebra
|q     | int,int \| int \| ? \| * \| `+`              | a quantifier denoting an "amount." `? = {0,1}`,`* = {-infty,+infty}`,`+ = {1,+infty}`
|{0}   | _{0,0}                                       | "none" or the zero-`obj`.
|dtype | ctype\<=ctype([inst]+)                       | a derived type inductively defined from a ctype base
|sep   | ; \| , \| '\|'                               | polynomial element separator. `;` is compose, `,` is branch, and `\|` is choose.
|rec   | [-] \| [obj->obj(<sep>obj->obj)*]            | a record has `obj` keys and `obj` values
|lst   | [ ] \| [obj(<sep>obj)*]                      | a list has `int` keys and `obj` values
|inst  | [op(,obj*)]                                  | an instruction has an opcode and arguments.
|op    | a, add, and, as, combine, count, eq, error,
         explain, fold, from, get, given, groupCount,
         gt, gte, head, id, is, last, lt, lte, map,
         merge, mult, neg, noop, one, or, path, plus,
         pow, put, q, repeat, split, start, tail, to,
         trace, type, zero                            | the opcodes supported by the mm-ADT VM
|sugop | . \| > \| < \| >= \| =< \| == \| * \| `+`    | infix operators
|===

The following https://en.wikipedia.org/wiki/Axiomatic_semantics[language axioms] have variables `x`, `y`, and `z` in `ctype` and `[a]` and `[b]` in `inst`.

[source]
----
id(x)                       := x<=x[id]
domain(y<=x[a])             := x
range(y<=x[a])              := y
domain(x)                   := x
range(x)                    := x
;-compose(y<=x[a],z<=y[b])  := z<=x[a][b]
+-compose(y<=x[a],y<=x[b])  := y<=x[branch,y<=x[a],y<=x[b]]
|-compose(y<=x[a],z<=x[b])  := y<=x[choose,y<=x[a],z<=x[b]
objA(valueB)                := valueB
objA(typeB)                 := typeB<=objA
objA(typeB[instA][instB])   := typeB<=objA[instA][instB]
----

The quantifiers of an `mmlang` program are elements of a ring with unity (the quantifier ring). In the following equations, `*` and `+` refer to the respective monoid and group operations of the program's associated quantifier ring.

[source]
----
;-compose(y{q1}<=x[a],z{q2}<=y[b]) := z{q1*q2}<=x[a][b]
+-compose(y{q1}<=x[a],y{q2}<=x[a]) := y{q1+q2}<=x[a]
+-compose(y{q1}<=x[a],y{q2}<=x[b]) := y{q1+q2}<=x[branch,y{q1}<=x[a],y{q2}<=x[b]]
|-compose(y{q1}<=x[a],y{q2}<=x[b]) := y{min(q1,q2),max(q1,q2)}<=x[branch,y{q1}<=x[a],y{q2}<=x[b]]
----

[source]
----
[compose,x[id],x[id]]                            := x
[branch,x[id],x[id]]                             := x{2}
[choose,x[id],x[id]]                             := x
[repeat,[obj{?}->{0},obj{?}->type,n]]            := type[pow,n]
----

[source]
----
domain<=range[op(,arg)*]     := operation or equivalence
--------------------------------------------------------
bool<=objA[a,objB]           := objA.test(objB)
bool<=boolA[and,boolB]       := boolA & boolB
int<=obj{*}[count]           := obj{*}[q]
bool<=objA[eq,objB]          := objA == objB
str<=obj{*}[explain]
...
----

Typing rules, where the `_` symbol refers to the __anonymous type__.

[source]
----
typeA(_)                           := typeA
typeA(_[instA][instB])             := instB(instA(typeA)) => typeB<=typeA[instA][instB]
obj[a,_]                           := true
typeA[a,typeA]                     := true
typeA[a,{0}]                       := typeA.q == 0,0
typeA[a,typeB]                     := typeA(typeB) != {0}
----
