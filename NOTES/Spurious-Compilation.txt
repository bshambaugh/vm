On The Spurious Distinction Between Types and Instances
                      and
    Its Role in Relating Inference and Evaluation 
                      in 
                     mm-ADT

          by: DÃ¶ktÅ«rd MarstrÃ¶m RÃ¸dreeguss
        Tijunana Intitute of Technology (TIT)

--------------------------------------------------------

Part 1: Obj and Inst
====================

Every expression in mm-ADT is of the form:

			x => y <= [z]

"x maps to a y that is algorithmically generated by applying y to the function [z]."

x is an obj    (an mm-ADT object).
y is an obj    (an mm-ADT object).
[z] is an inst (an mm-ADT instruction).

Two examples demonstrating the spurious distinction between types and instances.

4   => 4   <= [id]      // instance ("concrete" obj)
int => int <= [id]      // type     ("abstract" obj)

"4 maps to 4 which is algorithmically generated by applying 4 to the identity function [id]."
"int maps to int which is algorithmically generated by applying int to the identity function [id].



Part 2: Applying Obj to Inst
============================

What does it mean to apply 4 to [id]? The monoid <obj,*> is sufficient.

	4 * [id] => 4

...in long hand:

	4 * [id] => 4 <= [id]

"4 applied to [id] maps to 4 which is algorithmically generated by applying 4 to [id]."

...in short hand:

	[start,4][id]   // but this is for another day when we discuss 
                        // the spurious distinction between structures and processes.



Part 3: Type Evaluation is Type Deduction
=========================================

4   * [mult,5] => 20  <= [id]
int * [mult,5] => int <= [mult,5]

4   * [mult,5] * [plus,10]  => 30  <= [id]                  // program evaluation (concrete deduction)
int * [mult,5] * [plus,10]  => int <= [mult,5][plus,10]     // type inference     (abstract deduction)


The domain and range of the instructions are computed (and checked) as int is propagated from:

 int => [mult,5] => int => [plus,10] => int
Domain                                 Range


Part 4: The Power of Quantifiers
================================

A "reference" is neither an instance nor a type. It sits between these two extremes.

	4,5,6,7 => int{4} <= [start,4,5,6,7]

It describes the general features of a collection like a type, but it also yields the elements like an instance.

Lets isolate the type component of the reference above.

	int{4} => int{4} <= [id]

The purpose of introducing references was to demonstrate quantifiers.

	int{4}  : this denotes 4 ints
	int     : this denotes 1 int -- just.
	int{?}  : this denotes 0 or 1 int -- maybe.
	int{0,1}: same as above where '?' is shorthand notation
	int{0}  : this denotes 0 ints -- none.
	...in general {x,y}
		types:      {x,y}  where x may equal y.
		instances:  {x,y}  where x = 1 = y.
		references: {x,y}  where x = y.

Lets use int{4} as the source of a type inference...

	int{4} * [count] => 4 <= [id]

And there is how the abstract world of types and type inference is naturally morphed 
into the concrete world of instances and program evaluation.

Most mm-ADT programs are two pass:
	1. type inference using the domain type as the initial term.
	2. program evaluation using a stream as the initial term.

...however, this distinction is spurious. Sometimes a single pass is all you need.

	int{4} * [count] * [count] * [plus,10] => 11 <= [id]